

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>src.pyLIQTR.BlockEncodings.DoubleFactorized &mdash; pyLIQTR 1.3.4 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/jupyter-sphinx.css" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/thebelab.css" />

  
    <link rel="shortcut icon" href="../../../../_static/pyliqtr_logo.png"/>
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=e358f374"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../../_static/thebelab-helper.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            pyLIQTR
              <img src="../../../../_static/pyliqtr_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../document.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../release.html">Release strategy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contribute.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../debugger.html">Debugger</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../best_practice.html">Best Practices</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api.html">pyLIQTR API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api-internal.html">Internal API reference, for users customizing behavior</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../_autosummary/pyLIQTR.html">pyLIQTR</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">pyLIQTR</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../BlockEncodings.html">src.pyLIQTR.BlockEncodings</a></li>
      <li class="breadcrumb-item active">src.pyLIQTR.BlockEncodings.DoubleFactorized</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for src.pyLIQTR.BlockEncodings.DoubleFactorized</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Copyright (c) 2024 Massachusetts Institute of Technology </span>
<span class="sd">SPDX-License-Identifier: BSD-2-Clause</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">qualtran</span> <span class="k">as</span> <span class="nn">qt</span>
<span class="kn">import</span> <span class="nn">cirq</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cached_property</span>
<span class="kn">from</span> <span class="nn">numpy.typing</span> <span class="kn">import</span> <span class="n">NDArray</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">from</span> <span class="nn">pyLIQTR.BlockEncodings</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pyLIQTR.BlockEncodings.BlockEncoding</span> <span class="kn">import</span> <span class="n">BlockEncoding</span>

<span class="kn">from</span> <span class="nn">pyLIQTR.circuits.operators.DF_OuterPrepare</span> <span class="kn">import</span> <span class="n">OuterPrepare</span>
<span class="kn">from</span> <span class="nn">pyLIQTR.circuits.operators.DF_InnerPrepare</span> <span class="kn">import</span> <span class="n">InnerPrepare</span>
<span class="kn">from</span> <span class="nn">pyLIQTR.circuits.operators.DF_RotationsBlock</span> <span class="kn">import</span> <span class="n">RotationsBlock</span>
<span class="kn">from</span> <span class="nn">pyLIQTR.circuits.operators.RotationsQROM</span> <span class="kn">import</span> <span class="n">RotationsQROM</span>

<span class="kn">from</span> <span class="nn">qualtran.linalg.lcu_util</span> <span class="kn">import</span> <span class="n">_differences</span><span class="p">,</span> <span class="n">_partial_sums</span>
<span class="kn">from</span> <span class="nn">qualtran.cirq_interop.bit_tools</span> <span class="kn">import</span> <span class="n">iter_bits_fixed_point</span>
<span class="kn">from</span> <span class="nn">qualtran.bloqs.mcmt.multi_control_multi_target_pauli</span> <span class="kn">import</span> <span class="n">MultiControlPauli</span>
<span class="kn">from</span> <span class="nn">qualtran.bloqs.rotations.phase_gradient</span> <span class="kn">import</span> <span class="n">PhaseGradientState</span>
<span class="kn">from</span> <span class="nn">qualtran.bloqs.data_loading</span> <span class="kn">import</span> <span class="n">QROM</span>
<span class="kn">from</span> <span class="nn">qualtran._infra.data_types</span> <span class="kn">import</span> <span class="n">BoundedQUInt</span><span class="p">,</span> <span class="n">QUInt</span><span class="p">,</span> <span class="n">QBit</span>
<span class="kn">from</span> <span class="nn">qualtran</span> <span class="kn">import</span> <span class="n">Register</span><span class="p">,</span> <span class="n">Signature</span><span class="p">,</span> <span class="n">Side</span>

<div class="viewcode-block" id="DoubleFactorized">
<a class="viewcode-back" href="../../../../docs/_modules/src.pyLIQTR.BlockEncodings.html#src.pyLIQTR.BlockEncodings.DoubleFactorized.DoubleFactorized">[docs]</a>
<span class="k">class</span> <span class="nc">DoubleFactorized</span><span class="p">(</span><span class="n">BlockEncoding</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implements encoding from Appendix C Figure 16 of Ref [1].</span>

<span class="sd">    References:</span>
<span class="sd">    [1] https://arxiv.org/abs/2011.03494</span>
<span class="sd">    [2] https://arxiv.org/abs/2007.14460</span>

<span class="sd">    :param ProblemInstance ProblemInstance: A pyLIQTR.ProblemInstance for the system of interest. Currently supports ChemicalHamiltonian instances.</span>
<span class="sd">    :param float df_error_threshold: The threshold used to throw out factors from the double factorization. Truncation is carried out as described in Appendix C Section 3 of Ref [1]. This parameter corresponds to the RHS of Eq C41.</span>
<span class="sd">    :param float sf_error_threshold: The threshold used to throw out factors from the first eigendecomposition. Terms with eigenvalues less than or equal to sf_error_threshold are thrown out. This decreases L, the rank of the two body tensor in eq C10.</span>
<span class="sd">    :param int br: The number of precision bits to use for the rotation angles output by the QROM in step 2 and used in step 3a)iv on page 52 of Ref [1]. Note, this is not used in step 1a which does not currently use a phase gradient rotation.</span>
<span class="sd">    :param float phase_gradient_eps: Overall error in gradient state preparation, ie each rotation done to prepare the phase gradient state will be performed with error phase_gradient_eps/bits_rot_givens</span>
<span class="sd">    :param float energy_error: The allowable error in phase estimation energy. Used to set bits_rot_givens, keep_bitsize, and outer_prep_eps if step_error is not passed as input.</span>

<span class="sd">    Optional inputs:</span>
<span class="sd">    </span>
<span class="sd">    :param float step_error: Error in spectral norm of walk operator. Corresponds to epsilon in eq C24 of Ref [1]. Used to set bits_rot_givens, keep_bitsize, and outer_prep_eps if those are not passed as inputs.</span>
<span class="sd">    :param int bits_rot_givens: The number of precision bits to use for the Givens rotations in step 4 on page 53 of Ref [1]. Called $\beth$ in Ref [1].</span>
<span class="sd">    :param innt keep_bitsize: Number of precision bits to use for preparing the coefficients on the second selection register (p). N2 in Eq C31 of Ref [1].</span>
<span class="sd">    :param float outer_prep_eps: Precision of normalized coefficients prepared on first selection register (l). Used to set N1 in Eq C27 of Ref [1].</span>

<span class="sd">    :returns: an instance of the DoubleFactorized() class</span>

<span class="sd">    :rtype: DoubleFactorized</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ProblemInstance</span><span class="p">,</span><span class="n">df_error_threshold</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span><span class="n">sf_error_threshold</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span><span class="n">br</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span><span class="n">phase_gradient_eps</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span><span class="n">energy_error</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span><span class="n">step_error</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">bits_rot_givens</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">keep_bitsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">outer_prep_eps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ProblemInstance</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">one_body_array</span><span class="p">,</span> <span class="n">two_body_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xi_l_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">givens_angle_tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PI</span><span class="o">.</span><span class="n">yield_DF_Info</span><span class="p">(</span><span class="n">df_error_threshold</span><span class="o">=</span><span class="n">df_error_threshold</span><span class="p">,</span><span class="n">sf_error_threshold</span><span class="o">=</span><span class="n">sf_error_threshold</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_encoding_type</span> <span class="o">=</span> <span class="n">VALID_ENCODINGS</span><span class="o">.</span><span class="n">DoubleFactorized</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">one_body_array</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="mi">2</span> <span class="c1"># number of spin orbitals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">two_body_array</span><span class="p">)</span> <span class="c1"># rank of two body tensor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">one_body_signs</span> <span class="o">=</span> <span class="n">one_body_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">one_body_mags</span> <span class="o">=</span> <span class="n">one_body_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># these correspond to |T_pq&#39;| in the ref</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">two_body_signs</span> <span class="o">=</span> <span class="p">[</span><span class="n">two_body_array</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">two_body_mags</span> <span class="o">=</span> <span class="p">[</span><span class="n">two_body_array</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)]</span> <span class="c1"># these correspond to |f_p^l| in the ref</span>
        

        <span class="c1"># define bit lengths for qubit registers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nL</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">nXi</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="c1">#ref says bitlength of max(Xi_l) but |p&gt; reg is used to index over one body coeffs too</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nLXi</span> <span class="o">=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xi_l_data</span><span class="p">)</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span>

        <span class="c1"># define error/precision related parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phase_gradient_eps</span> <span class="o">=</span> <span class="n">phase_gradient_eps</span>  <span class="c1">#overall error in gradient state preparation, ie each rotation done to prepare the phase gradient state will be performed with error eps/bgrad where here bgrad = bits_rot_givens</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_error_threshold</span> <span class="o">=</span> <span class="n">df_error_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sf_error_threshold</span> <span class="o">=</span> <span class="n">sf_error_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">br</span> <span class="o">=</span> <span class="n">br</span> <span class="c1"># bits precision for single qubit rotation in amplitude amplification in outer and inner prep</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">energy_error</span> <span class="o">=</span> <span class="n">energy_error</span>

        <span class="c1">## defaults for optional input parameters based on energy_error if step_error not provided</span>
        <span class="k">if</span> <span class="n">step_error</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># default based on paragraph below Eq 1 of Ref [2]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">step_error</span> <span class="o">=</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">energy_error</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">step_error</span> <span class="o">=</span> <span class="n">step_error</span>
        <span class="k">if</span> <span class="n">bits_rot_givens</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># default based on Eq C24 of Ref [1]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bits_rot_givens</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">5.652</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">step_error</span><span class="p">))))</span><span class="c1"># bits precision for givens angle rotations in controlled rotations block, called $\beth$ in ref Eq C24</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bits_rot_givens</span> <span class="o">=</span> <span class="n">bits_rot_givens</span>
        <span class="k">if</span> <span class="n">keep_bitsize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keep_bitsize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">2.5</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">step_error</span><span class="p">)))</span> <span class="c1"># N in Eq C14</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keep_bitsize</span> <span class="o">=</span> <span class="n">keep_bitsize</span>
        <span class="k">if</span> <span class="n">outer_prep_eps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outer_prep_eps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_error</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outer_prep_eps</span> <span class="o">=</span> <span class="n">outer_prep_eps</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">keep_bitsize_outer</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outer_prep_eps</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">+</span><span class="mi">1</span><span class="p">)))))</span> <span class="c1"># N1 in Eq C27</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;returns the double factorized Hamiltonian norm.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">PI</span><span class="o">.</span><span class="n">get_alpha</span><span class="p">(</span><span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;DF&#39;</span><span class="p">,</span><span class="n">df_error_threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">df_error_threshold</span><span class="p">,</span><span class="n">sf_error_threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sf_error_threshold</span><span class="p">)</span>
    
    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">control_registers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Register</span><span class="p">]:</span>
        <span class="n">registers</span> <span class="o">=</span> <span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_control_val</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">Register</span><span class="p">(</span><span class="s1">&#39;control&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">QBit</span><span class="p">()),)</span>
        <span class="k">return</span> <span class="n">registers</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">selection_registers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Register</span><span class="p">]:</span>
        <span class="n">l_reg</span> <span class="o">=</span> <span class="n">Register</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;l&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">BoundedQUInt</span><span class="p">(</span><span class="n">bitsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nL</span><span class="p">,</span><span class="n">iteration_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">p_reg</span> <span class="o">=</span> <span class="n">Register</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;p&#39;</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">BoundedQUInt</span><span class="p">(</span><span class="n">bitsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nXi</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">l_reg</span><span class="p">,</span> <span class="n">p_reg</span><span class="p">)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">extra_registers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Register</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">Signature</span><span class="p">(</span>
            <span class="p">[</span> <span class="n">Register</span><span class="p">(</span><span class="s1">&#39;succ_l&#39;</span><span class="p">,</span> <span class="n">QBit</span><span class="p">()),</span>
            <span class="n">Register</span><span class="p">(</span><span class="s1">&#39;l_neq_0&#39;</span><span class="p">,</span> <span class="n">QBit</span><span class="p">()),</span>
            <span class="n">Register</span><span class="p">(</span><span class="s1">&#39;Xi_l&#39;</span><span class="p">,</span> <span class="n">QUInt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nXi</span><span class="p">)),</span>
            <span class="n">Register</span><span class="p">(</span><span class="s1">&#39;offset&#39;</span><span class="p">,</span> <span class="n">QUInt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nLXi</span><span class="p">)),</span>
            <span class="n">Register</span><span class="p">(</span><span class="s1">&#39;rot_data&#39;</span><span class="p">,</span> <span class="n">QUInt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">br</span><span class="p">)),</span>
            <span class="n">Register</span><span class="p">(</span><span class="s1">&#39;succ_p&#39;</span><span class="p">,</span> <span class="n">QBit</span><span class="p">()),</span>
            <span class="n">Register</span><span class="p">(</span><span class="s1">&#39;rotations&#39;</span><span class="p">,</span> <span class="n">QUInt</span><span class="p">(</span><span class="nb">int</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bits_rot_givens</span><span class="p">))),</span>
            <span class="n">Register</span><span class="p">(</span><span class="s1">&#39;spin_select&#39;</span><span class="p">,</span> <span class="n">QBit</span><span class="p">()),</span>
            <span class="n">Register</span><span class="p">(</span><span class="s1">&#39;zero_padding&#39;</span><span class="p">,</span> <span class="n">QUInt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nLXi</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">nXi</span><span class="p">)),</span>
            <span class="n">Register</span><span class="p">(</span><span class="s1">&#39;sign&#39;</span><span class="p">,</span> <span class="n">QBit</span><span class="p">()),</span>
            <span class="n">Register</span><span class="p">(</span><span class="s1">&#39;phi&#39;</span><span class="p">,</span> <span class="n">QUInt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bits_rot_givens</span><span class="p">),</span><span class="n">side</span><span class="o">=</span><span class="n">Side</span><span class="o">.</span><span class="n">RIGHT</span><span class="p">),</span> <span class="c1"># phase gradient state </span>
            <span class="n">Register</span><span class="p">(</span><span class="s1">&#39;less_than_equal_ancilla&#39;</span><span class="p">,</span> <span class="n">QBit</span><span class="p">())</span> <span class="p">]</span>
        <span class="p">)</span>
    
    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">inner_prep_extra_registers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Register</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">Signature</span><span class="p">(</span>
            <span class="p">[</span> <span class="n">Register</span><span class="p">(</span><span class="s1">&#39;contiguous_index&#39;</span><span class="p">,</span> <span class="n">BoundedQUInt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nLXi</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">side</span><span class="o">=</span><span class="n">Side</span><span class="o">.</span><span class="n">RIGHT</span><span class="p">),</span>
            <span class="n">Register</span><span class="p">(</span><span class="s1">&#39;rot_ancilla&#39;</span><span class="p">,</span> <span class="n">QBit</span><span class="p">()),</span> <span class="c1"># target for aa rotation</span>
            <span class="n">Register</span><span class="p">(</span><span class="s1">&#39;unary_ancilla&#39;</span><span class="p">,</span> <span class="n">QUInt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nXi</span><span class="p">)),</span>
            <span class="n">Register</span><span class="p">(</span><span class="s1">&#39;alt&#39;</span><span class="p">,</span> <span class="n">QUInt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nXi</span><span class="p">)),</span>
            <span class="n">Register</span><span class="p">(</span><span class="s1">&#39;keep&#39;</span><span class="p">,</span> <span class="n">QUInt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keep_bitsize</span><span class="p">)),</span>
            <span class="n">Register</span><span class="p">(</span><span class="s1">&#39;alt_sign&#39;</span><span class="p">,</span> <span class="n">QBit</span><span class="p">()),</span>
            <span class="n">Register</span><span class="p">(</span><span class="s1">&#39;sigma&#39;</span><span class="p">,</span> <span class="n">QUInt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keep_bitsize</span><span class="p">))</span> <span class="p">]</span>
        <span class="p">)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">outer_prep_extra_registers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Register</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">(</span> <span class="n">Signature</span><span class="o">.</span><span class="n">build</span><span class="p">(</span>
            <span class="n">alt_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nL</span><span class="p">,</span>
            <span class="n">keep_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_bitsize_outer</span><span class="p">,</span>
            <span class="n">sigma_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_bitsize_outer</span><span class="p">,</span>
        <span class="p">))</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">target_registers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Register</span><span class="p">]:</span>
        <span class="n">halfN</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span> <span class="n">Signature</span><span class="o">.</span><span class="n">build</span><span class="p">(</span>
            <span class="n">target_spin_up</span> <span class="o">=</span> <span class="n">halfN</span><span class="p">,</span>
            <span class="n">target_spin_down</span> <span class="o">=</span> <span class="n">halfN</span>
        <span class="p">))</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">signature</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Signature</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Signature</span><span class="p">(</span>
            <span class="p">[</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">control_registers</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">selection_registers</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">extra_registers</span><span class="p">,</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">inner_prep_extra_registers</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">outer_prep_extra_registers</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">target_registers</span><span class="p">]</span>
        <span class="p">)</span>

<div class="viewcode-block" id="DoubleFactorized.compute_data_l">
<a class="viewcode-back" href="../../../../docs/_modules/src.pyLIQTR.BlockEncodings.html#src.pyLIQTR.BlockEncodings.DoubleFactorized.DoubleFactorized.compute_data_l">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_data_l</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;returns the data to be loaded using a qrom.&quot;&quot;&quot;</span>
        <span class="n">l_neq_0_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">l_neq_0_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># 0 for first entry, one otherwise</span>

        <span class="n">halfN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">Xi_l_data_with_1B</span> <span class="o">=</span> <span class="p">[</span><span class="n">halfN</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">Xi_l_data</span> <span class="c1"># first element should be number of one-electron terms</span>
        <span class="n">Xi_l_data_with_1B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Xi_l_data_with_1B</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="c1"># shift down 1 since summation indexing starts at 0</span>

        <span class="c1"># compute offsets</span>
        <span class="n">offset_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">_partial_sums</span><span class="p">(</span><span class="n">Xi_l_data_with_1B</span><span class="p">)))[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># compute rotation angles based on truncations (Xi_l)</span>
        <span class="n">floor_n_Xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">Xi_l_data_with_1B</span><span class="p">))</span>
        <span class="n">rotation_angles</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">**</span><span class="n">floor_n_Xi</span> <span class="o">/</span> <span class="n">Xi_l_data_with_1B</span><span class="p">)</span>
        <span class="c1"># account for num bits rotation</span>
        <span class="n">rot_data</span> <span class="o">=</span> <span class="n">approx_angles_as_ints_with_br_bits</span><span class="p">(</span><span class="n">rotation_angles</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">br</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">l_neq_0_data</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Xi_l_data_with_1B</span><span class="p">),</span><span class="n">offset_data</span><span class="p">,</span><span class="n">rot_data</span><span class="p">)</span></div>


<div class="viewcode-block" id="DoubleFactorized.get_givens_angles">
<a class="viewcode-back" href="../../../../docs/_modules/src.pyLIQTR.BlockEncodings.html#src.pyLIQTR.BlockEncodings.DoubleFactorized.DoubleFactorized.get_givens_angles">[docs]</a>
    <span class="k">def</span> <span class="nf">get_givens_angles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;returns the Givens rotation angles in binary form for the basis transformation rotations.&quot;&quot;&quot;</span>
        <span class="c1"># B = bits_rot_givens</span>
        <span class="c1"># There are N/2-1 rotations per coefficient, each rotation angle uses B bits </span>
        <span class="c1"># qrom indexes over number of coefficients (call it M) so</span>
        <span class="c1"># for m in M:</span>
        <span class="c1"># givens_angles[m] = np.zeros(B*(N/2-1))</span>
        <span class="c1"># such that there are N/2-1 batches of B bits, ie </span>
        <span class="c1"># for i in range(N/2-1)</span>
        <span class="c1">#   givens_angles[m,i*B:(i+1)*B] = ith rotation angle</span>
        <span class="n">halfN</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">p_sum_limits</span> <span class="o">=</span> <span class="p">[</span><span class="n">halfN</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">Xi_l_data</span>
        <span class="n">num_coeffs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">p_sum_limits</span><span class="p">))</span>
        <span class="n">givens_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_coeffs</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">bits_rot_givens</span><span class="o">*</span><span class="p">(</span><span class="n">halfN</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
        <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p_sum_limits</span><span class="p">[</span><span class="n">l</span><span class="p">]):</span> 
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">theta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">givens_angle_tensor</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">p</span><span class="p">,:]):</span>
                    <span class="n">theta_normalized</span> <span class="o">=</span> <span class="n">theta</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span> <span class="mi">1</span>
                    <span class="n">binary_theta</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">iter_bits_fixed_point</span><span class="p">(</span><span class="n">theta_normalized</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bits_rot_givens</span><span class="p">))</span>
                    <span class="n">givens_angles</span><span class="p">[</span><span class="n">m</span><span class="p">,</span><span class="n">i</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bits_rot_givens</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bits_rot_givens</span><span class="p">]</span> <span class="o">=</span> <span class="n">binary_theta</span> <span class="c1">#lsb is last element in list</span>
                <span class="n">m</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">givens_angles</span></div>



<div class="viewcode-block" id="DoubleFactorized.decompose_from_registers">
<a class="viewcode-back" href="../../../../docs/_modules/src.pyLIQTR.BlockEncodings.html#src.pyLIQTR.BlockEncodings.DoubleFactorized.DoubleFactorized.decompose_from_registers">[docs]</a>
    <span class="k">def</span> <span class="nf">decompose_from_registers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="o">**</span><span class="n">quregs</span><span class="p">):</span>
        <span class="n">control</span> <span class="o">=</span> <span class="n">quregs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;control&#39;</span><span class="p">,</span> <span class="p">())</span>
        <span class="n">succ_l</span><span class="p">,</span> <span class="n">l_reg</span> <span class="o">=</span> <span class="n">quregs</span><span class="p">[</span><span class="s1">&#39;succ_l&#39;</span><span class="p">],</span> <span class="n">quregs</span><span class="p">[</span><span class="s1">&#39;l&#39;</span><span class="p">]</span>
        <span class="n">l_neq_0</span><span class="p">,</span> <span class="n">Xi_l</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">rot</span> <span class="o">=</span> <span class="n">quregs</span><span class="p">[</span><span class="s1">&#39;l_neq_0&#39;</span><span class="p">],</span> <span class="n">quregs</span><span class="p">[</span><span class="s1">&#39;Xi_l&#39;</span><span class="p">],</span> <span class="n">quregs</span><span class="p">[</span><span class="s1">&#39;offset&#39;</span><span class="p">],</span> <span class="n">quregs</span><span class="p">[</span><span class="s1">&#39;rot_data&#39;</span><span class="p">]</span>
        <span class="n">succ_p</span><span class="p">,</span> <span class="n">p_reg</span> <span class="o">=</span> <span class="n">quregs</span><span class="p">[</span><span class="s1">&#39;succ_p&#39;</span><span class="p">],</span> <span class="n">quregs</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span>
        <span class="n">rotations</span><span class="p">,</span> <span class="n">spin_select</span> <span class="o">=</span> <span class="n">quregs</span><span class="p">[</span><span class="s1">&#39;rotations&#39;</span><span class="p">],</span> <span class="n">quregs</span><span class="p">[</span><span class="s1">&#39;spin_select&#39;</span><span class="p">]</span>
        <span class="n">target_up</span><span class="p">,</span> <span class="n">target_down</span> <span class="o">=</span> <span class="n">quregs</span><span class="p">[</span><span class="s1">&#39;target_spin_up&#39;</span><span class="p">],</span> <span class="n">quregs</span><span class="p">[</span><span class="s1">&#39;target_spin_down&#39;</span><span class="p">]</span>
        <span class="n">zero_padding</span> <span class="o">=</span> <span class="n">quregs</span><span class="p">[</span><span class="s1">&#39;zero_padding&#39;</span><span class="p">]</span>
        <span class="n">sign_qb</span> <span class="o">=</span> <span class="n">quregs</span><span class="p">[</span><span class="s1">&#39;sign&#39;</span><span class="p">]</span>
        <span class="n">phase_gradient_state</span> <span class="o">=</span> <span class="n">quregs</span><span class="p">[</span><span class="s1">&#39;phi&#39;</span><span class="p">]</span>
        <span class="n">rot_aa_ancilla</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">quregs</span><span class="p">[</span><span class="s1">&#39;rot_ancilla&#39;</span><span class="p">],</span> <span class="n">quregs</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span>
        <span class="n">sigma_l</span><span class="p">,</span> <span class="n">alt_l</span><span class="p">,</span> <span class="n">keep_l</span> <span class="o">=</span> <span class="n">quregs</span><span class="p">[</span><span class="s1">&#39;sigma_l&#39;</span><span class="p">],</span> <span class="n">quregs</span><span class="p">[</span><span class="s1">&#39;alt_l&#39;</span><span class="p">],</span> <span class="n">quregs</span><span class="p">[</span><span class="s1">&#39;keep_l&#39;</span><span class="p">]</span>
        <span class="n">less_than_equal_ancilla</span> <span class="o">=</span> <span class="n">quregs</span><span class="p">[</span><span class="s1">&#39;less_than_equal_ancilla&#39;</span><span class="p">]</span>

        <span class="c1"># prepare phase gradient state</span>
        <span class="c1"># TODO what should eps be for preparing phase gradient state (eps is overall error in gradient state preparation, ie each rotation will be performed with error eps/bgrad where here bgrad = bits_rot_givens)</span>
        <span class="k">yield</span> <span class="n">PhaseGradientState</span><span class="p">(</span><span class="n">bitsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bits_rot_givens</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_gradient_eps</span><span class="p">)</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="o">*</span><span class="n">phase_gradient_state</span><span class="p">)</span>
        
        <span class="c1"># prepare superposition over l</span>
        <span class="c1"># calculate outer coeffs. First element should be l=0 term (ie sum(Tpq)), then l=1 to L terms correspond to sum_p(fp^l)</span>
        <span class="n">outer_coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">one_body_mags</span><span class="p">)],</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">two_body_mags</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
        <span class="n">outer_prep</span> <span class="o">=</span> <span class="n">OuterPrepare</span><span class="o">.</span><span class="n">from_lcu_probs</span><span class="p">(</span><span class="n">lcu_probabilities</span><span class="o">=</span><span class="n">outer_coefficients</span><span class="p">,</span><span class="n">probability_epsilon</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">outer_prep_eps</span><span class="p">)</span> <span class="c1">#epsilon should be consistent with keep_bitsize_outer</span>
        <span class="k">yield</span> <span class="n">outer_prep</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="n">success</span><span class="o">=</span><span class="n">succ_l</span><span class="p">,</span><span class="n">selection</span><span class="o">=</span><span class="n">l_reg</span><span class="p">,</span><span class="n">sigma_mu</span><span class="o">=</span><span class="n">sigma_l</span><span class="p">,</span><span class="n">alt</span><span class="o">=</span><span class="n">alt_l</span><span class="p">,</span><span class="n">keep</span><span class="o">=</span><span class="n">keep_l</span><span class="p">,</span><span class="n">less_than_equal</span><span class="o">=</span><span class="n">less_than_equal_ancilla</span><span class="p">)</span>

        <span class="c1"># load l != 0, Xi^l (truncation), offset, and rot (amplitude amplification) data</span>
        <span class="n">l_neq_0_data</span><span class="p">,</span><span class="n">Xi_l_data_with_1B</span><span class="p">,</span><span class="n">offset_data</span><span class="p">,</span><span class="n">rot_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_data_l</span><span class="p">()</span>
        <span class="c1"># </span>
        <span class="n">qrom_gate</span> <span class="o">=</span> <span class="n">QROM</span><span class="p">(</span>
            <span class="p">[</span><span class="n">l_neq_0_data</span><span class="p">,</span><span class="n">Xi_l_data_with_1B</span><span class="p">,</span><span class="n">offset_data</span><span class="p">,</span><span class="n">rot_data</span><span class="p">],</span>
            <span class="n">selection_bitsizes</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nL</span><span class="p">,),</span>
            <span class="n">target_bitsizes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nXi</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nLXi</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">br</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">yield</span> <span class="n">qrom_gate</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="n">selection</span><span class="o">=</span><span class="n">l_reg</span><span class="p">,</span><span class="n">target0_</span><span class="o">=</span><span class="n">l_neq_0</span><span class="p">,</span><span class="n">target1_</span><span class="o">=</span><span class="n">Xi_l</span><span class="p">,</span><span class="n">target2_</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span><span class="n">target3_</span><span class="o">=</span><span class="n">rot</span><span class="p">)</span>

        <span class="c1"># prepare superposition over p</span>
        <span class="n">In_prep_l</span> <span class="o">=</span> <span class="n">InnerPrepare</span><span class="o">.</span><span class="n">from_Tf_arrays</span><span class="p">(</span><span class="n">T_coeffs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">one_body_mags</span><span class="p">,</span><span class="n">T_signs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">one_body_signs</span><span class="p">,</span> <span class="n">fpl_coeffs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">two_body_mags</span><span class="p">,</span> <span class="n">fpl_signs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">two_body_signs</span><span class="p">,</span><span class="n">Xi_vals</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Xi_l_data</span><span class="p">,</span><span class="n">keep_bitsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">keep_bitsize</span><span class="p">,</span><span class="n">br</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">br</span><span class="p">,</span><span class="n">bphi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bits_rot_givens</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">In_prep_l</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="o">**</span><span class="n">quregs</span><span class="p">)</span>

        <span class="c1"># add p and offset to create contiguous register. contiguous index should iterate over all coefficients which corresponds to the range [0, sum(Xi_l)+N/2-1]</span>
        <span class="k">yield</span> <span class="n">qt</span><span class="o">.</span><span class="n">bloqs</span><span class="o">.</span><span class="n">arithmetic</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">a_dtype</span><span class="o">=</span><span class="n">QUInt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nLXi</span><span class="p">))</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">zero_padding</span><span class="p">)</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">p_reg</span><span class="p">))</span>

        <span class="c1"># QROM for Givens rotation angles</span>
        <span class="n">givens_angles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_givens_angles</span><span class="p">()</span>
        <span class="n">qrom_rotations</span> <span class="o">=</span> <span class="n">RotationsQROM</span><span class="p">(</span>
            <span class="p">[</span><span class="n">givens_angles</span><span class="p">],</span>
            <span class="n">selection_bitsizes</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nLXi</span><span class="p">,),</span>
            <span class="n">target_bitsizes</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rotations</span><span class="p">),)</span>
        <span class="p">)</span>
        <span class="c1"># TODO: implement optimal data loading with clean ancilla based on https://arxiv.org/pdf/1902.02134.pdf appendix B</span>
        <span class="k">yield</span> <span class="n">qrom_rotations</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="n">selection</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">zero_padding</span><span class="p">)</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">p_reg</span><span class="p">),</span><span class="n">target0_</span><span class="o">=</span><span class="n">rotations</span><span class="p">)</span>

        <span class="c1"># prepare system registers</span>
        <span class="k">yield</span> <span class="n">cirq</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="o">*</span><span class="n">spin_select</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">qt</span><span class="o">.</span><span class="n">bloqs</span><span class="o">.</span><span class="n">basic_gates</span><span class="o">.</span><span class="n">swap</span><span class="o">.</span><span class="n">CSwap</span><span class="o">.</span><span class="n">make_on</span><span class="p">(</span><span class="n">ctrl</span><span class="o">=</span><span class="n">spin_select</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">target_down</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">target_up</span><span class="p">)</span>
        
        <span class="c1"># controlled rotations</span>
        <span class="n">controlled_rotations</span> <span class="o">=</span> <span class="n">RotationsBlock</span><span class="p">(</span><span class="n">num_data_bits</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">rotations</span><span class="p">),</span><span class="n">num_target_bits</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">target_down</span><span class="p">),</span><span class="n">precision_bits</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bits_rot_givens</span><span class="p">,</span><span class="n">phase_gradient_bits</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bits_rot_givens</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">controlled_rotations</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="n">angle_data</span><span class="o">=</span><span class="n">rotations</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">target_down</span><span class="p">,</span><span class="n">phi</span><span class="o">=</span><span class="n">phase_gradient_state</span><span class="p">)</span>

        <span class="n">Z1</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">ZPowGate</span><span class="p">(</span><span class="n">exponent</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">global_shift</span><span class="o">=-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_controlled</span><span class="p">:</span>
            <span class="n">control_bits</span> <span class="o">=</span> <span class="p">[[</span><span class="n">bit</span><span class="p">]</span> <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="p">[</span><span class="o">*</span><span class="n">succ_l</span><span class="p">,</span><span class="o">*</span><span class="n">succ_p</span><span class="p">]]</span>
            <span class="c1"># controlled Z1 </span>
            <span class="n">controlled_Z1</span> <span class="o">=</span> <span class="n">MultiControlPauli</span><span class="p">(</span><span class="n">cvs</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">target_gate</span><span class="o">=</span><span class="n">Z1</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">controlled_Z1</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="n">controls</span><span class="o">=</span><span class="n">control_bits</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">target_down</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># controlled Z for sign qubit</span>
            <span class="n">sign_controlled_Z</span> <span class="o">=</span> <span class="n">MultiControlPauli</span><span class="p">(</span><span class="n">cvs</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">target_gate</span><span class="o">=</span><span class="n">cirq</span><span class="o">.</span><span class="n">Z</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">sign_controlled_Z</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="n">controls</span><span class="o">=</span><span class="n">control_bits</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">sign_qb</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">control_bits</span> <span class="o">=</span> <span class="p">[[</span><span class="n">bit</span><span class="p">]</span> <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="p">[</span><span class="o">*</span><span class="n">control</span><span class="p">,</span><span class="o">*</span><span class="n">succ_l</span><span class="p">,</span><span class="o">*</span><span class="n">succ_p</span><span class="p">]]</span>
            <span class="c1"># controlled Z1</span>
            <span class="n">controlled_Z1</span> <span class="o">=</span> <span class="n">MultiControlPauli</span><span class="p">(</span><span class="n">cvs</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_control_val</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">target_gate</span><span class="o">=</span><span class="n">Z1</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">controlled_Z1</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="n">controls</span><span class="o">=</span><span class="n">control_bits</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">target_down</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># controlled Z for sign qubit</span>
            <span class="n">sign_controlled_Z</span> <span class="o">=</span> <span class="n">MultiControlPauli</span><span class="p">(</span><span class="n">cvs</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_control_val</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">target_gate</span><span class="o">=</span><span class="n">cirq</span><span class="o">.</span><span class="n">Z</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">sign_controlled_Z</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="n">controls</span><span class="o">=</span><span class="n">control_bits</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">sign_qb</span><span class="p">)</span>
        <span class="c1">#################################### partial uncompute ####################################</span>

        <span class="c1">## undo controlled rotations</span>
        <span class="k">yield</span> <span class="n">controlled_rotations</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="n">angle_data</span><span class="o">=</span><span class="n">rotations</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">target_down</span><span class="p">,</span><span class="n">phi</span><span class="o">=</span><span class="n">phase_gradient_state</span><span class="p">)</span>

        <span class="c1">## undo givens qrom using measurement based uncompute</span>
        <span class="k">yield</span> <span class="n">qrom_rotations</span><span class="o">.</span><span class="n">measurement_uncompute</span><span class="p">(</span><span class="n">selection</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">zero_padding</span><span class="p">)</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">p_reg</span><span class="p">),</span><span class="n">data</span><span class="o">=</span><span class="n">rotations</span><span class="p">,</span><span class="n">measurement_key</span><span class="o">=</span><span class="s1">&#39;first_qrom_data_measurement&#39;</span><span class="p">)</span>

        <span class="c1">## undo prepare system registers</span>
        <span class="k">yield</span> <span class="n">qt</span><span class="o">.</span><span class="n">bloqs</span><span class="o">.</span><span class="n">basic_gates</span><span class="o">.</span><span class="n">swap</span><span class="o">.</span><span class="n">CSwap</span><span class="o">.</span><span class="n">make_on</span><span class="p">(</span><span class="n">ctrl</span><span class="o">=</span><span class="n">spin_select</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">target_down</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">target_up</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">cirq</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="o">*</span><span class="n">spin_select</span><span class="p">)</span>

        <span class="c1">## undo contiguous register addition</span>
        <span class="c1"># TODO: should this just be subtraction?</span>
        <span class="k">yield</span> <span class="n">cirq</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">bloqs</span><span class="o">.</span><span class="n">arithmetic</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">a_dtype</span><span class="o">=</span><span class="n">QUInt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nLXi</span><span class="p">))</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">zero_padding</span><span class="p">)</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">p_reg</span><span class="p">)))</span>

        <span class="c1">## undo InnerPrepare</span>
        <span class="k">yield</span> <span class="n">cirq</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">In_prep_l</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="o">**</span><span class="n">quregs</span><span class="p">))</span>

        <span class="c1">#################################### reflect ####################################</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_controlled</span><span class="p">:</span>
            <span class="n">control_bits</span> <span class="o">=</span> <span class="p">[[</span><span class="n">bit</span><span class="p">]</span> <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="p">[</span><span class="o">*</span><span class="n">succ_l</span><span class="p">,</span><span class="o">*</span><span class="n">l_neq_0</span><span class="p">,</span><span class="o">*</span><span class="n">p_reg</span><span class="p">,</span><span class="o">*</span><span class="n">rot_aa_ancilla</span><span class="p">,</span><span class="o">*</span><span class="n">sigma</span><span class="p">]]</span>
            <span class="n">reflect</span> <span class="o">=</span> <span class="n">MultiControlPauli</span><span class="p">(</span><span class="n">cvs</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,)</span><span class="o">+</span><span class="p">(</span><span class="mi">0</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nXi</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">keep_bitsize</span><span class="p">),</span><span class="n">target_gate</span><span class="o">=</span><span class="n">cirq</span><span class="o">.</span><span class="n">Z</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">reflect</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="n">controls</span><span class="o">=</span><span class="n">control_bits</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">spin_select</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">control_bits</span> <span class="o">=</span> <span class="p">[[</span><span class="n">bit</span><span class="p">]</span> <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="p">[</span><span class="o">*</span><span class="n">control</span><span class="p">,</span><span class="o">*</span><span class="n">succ_l</span><span class="p">,</span><span class="o">*</span><span class="n">l_neq_0</span><span class="p">,</span><span class="o">*</span><span class="n">p_reg</span><span class="p">,</span><span class="o">*</span><span class="n">rot_aa_ancilla</span><span class="p">,</span><span class="o">*</span><span class="n">sigma</span><span class="p">]]</span>
            <span class="n">reflect</span> <span class="o">=</span> <span class="n">MultiControlPauli</span><span class="p">(</span><span class="n">cvs</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_control_val</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,)</span><span class="o">+</span><span class="p">(</span><span class="mi">0</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nXi</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">keep_bitsize</span><span class="p">),</span><span class="n">target_gate</span><span class="o">=</span><span class="n">cirq</span><span class="o">.</span><span class="n">Z</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">reflect</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="n">controls</span><span class="o">=</span><span class="n">control_bits</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">spin_select</span><span class="p">)</span>

        <span class="c1">#################################### redo steps BUT for two-body term only ####################################</span>

        <span class="c1"># prepare superposition over p</span>
        <span class="c1"># one-body coefficients aren&#39;t needed so set T&#39;=0</span>
        <span class="n">In_prep_l_2b</span> <span class="o">=</span> <span class="n">InnerPrepare</span><span class="o">.</span><span class="n">from_Tf_arrays</span><span class="p">(</span><span class="n">T_coeffs</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">one_body_mags</span><span class="p">),</span><span class="n">T_signs</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">one_body_signs</span><span class="p">),</span> <span class="n">fpl_coeffs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">two_body_mags</span><span class="p">,</span> <span class="n">fpl_signs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">two_body_signs</span><span class="p">,</span><span class="n">Xi_vals</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Xi_l_data</span><span class="p">,</span><span class="n">keep_bitsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">keep_bitsize</span><span class="p">,</span><span class="n">br</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">br</span><span class="p">,</span><span class="n">bphi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bits_rot_givens</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">In_prep_l_2b</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="o">**</span><span class="n">quregs</span><span class="p">)</span>

        <span class="c1"># add p and offset to create contiguous register. contiguous index should iterate over all coefficients which corresponds to the range [0, sum(Xi_l)+N/2-1]</span>
        <span class="k">yield</span> <span class="n">qt</span><span class="o">.</span><span class="n">bloqs</span><span class="o">.</span><span class="n">arithmetic</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">a_dtype</span><span class="o">=</span><span class="n">QUInt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nLXi</span><span class="p">))</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">zero_padding</span><span class="p">)</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">p_reg</span><span class="p">))</span>

        <span class="c1"># QROM for Givens rotation angles</span>
        <span class="c1"># TODO: only need to load angles for two body tensor</span>
        <span class="k">yield</span> <span class="n">qrom_rotations</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="n">selection</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">zero_padding</span><span class="p">)</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">p_reg</span><span class="p">),</span><span class="n">target0_</span><span class="o">=</span><span class="n">rotations</span><span class="p">)</span>

        <span class="c1"># prepare system registers</span>
        <span class="k">yield</span> <span class="n">cirq</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="o">*</span><span class="n">spin_select</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">qt</span><span class="o">.</span><span class="n">bloqs</span><span class="o">.</span><span class="n">basic_gates</span><span class="o">.</span><span class="n">swap</span><span class="o">.</span><span class="n">CSwap</span><span class="o">.</span><span class="n">make_on</span><span class="p">(</span><span class="n">ctrl</span><span class="o">=</span><span class="n">spin_select</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">target_down</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">target_up</span><span class="p">)</span>
        
        <span class="c1"># controlled rotations</span>
        <span class="k">yield</span> <span class="n">controlled_rotations</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="n">angle_data</span><span class="o">=</span><span class="n">rotations</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">target_down</span><span class="p">,</span><span class="n">phi</span><span class="o">=</span><span class="n">phase_gradient_state</span><span class="p">)</span>

        <span class="c1"># controlled Z1 </span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_controlled</span><span class="p">:</span>
            <span class="n">control_bits</span> <span class="o">=</span> <span class="p">[[</span><span class="n">bit</span><span class="p">]</span> <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="p">[</span><span class="o">*</span><span class="n">succ_l</span><span class="p">,</span><span class="o">*</span><span class="n">succ_p</span><span class="p">,</span><span class="o">*</span><span class="n">l_neq_0</span><span class="p">]]</span>
            <span class="c1"># controlled Z1 </span>
            <span class="n">more_controlled_Z1</span> <span class="o">=</span> <span class="n">MultiControlPauli</span><span class="p">(</span><span class="n">cvs</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">target_gate</span><span class="o">=</span><span class="n">Z1</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">more_controlled_Z1</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="n">controls</span><span class="o">=</span><span class="n">control_bits</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">target_down</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># controlled Z for sign qubit</span>
            <span class="n">sign_more_controlled_Z</span> <span class="o">=</span> <span class="n">MultiControlPauli</span><span class="p">(</span><span class="n">cvs</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">target_gate</span><span class="o">=</span><span class="n">cirq</span><span class="o">.</span><span class="n">Z</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">sign_more_controlled_Z</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="n">controls</span><span class="o">=</span><span class="n">control_bits</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">sign_qb</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">control_bits</span> <span class="o">=</span> <span class="p">[[</span><span class="n">bit</span><span class="p">]</span> <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="p">[</span><span class="o">*</span><span class="n">control</span><span class="p">,</span><span class="o">*</span><span class="n">succ_l</span><span class="p">,</span><span class="o">*</span><span class="n">succ_p</span><span class="p">,</span><span class="o">*</span><span class="n">l_neq_0</span><span class="p">]]</span>
            <span class="c1"># controlled Z1</span>
            <span class="n">more_controlled_Z1</span> <span class="o">=</span> <span class="n">MultiControlPauli</span><span class="p">(</span><span class="n">cvs</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_control_val</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">target_gate</span><span class="o">=</span><span class="n">Z1</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">more_controlled_Z1</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="n">controls</span><span class="o">=</span><span class="n">control_bits</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">target_down</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># controlled Z for sign qubit</span>
            <span class="n">sign_more_controlled_Z</span> <span class="o">=</span> <span class="n">MultiControlPauli</span><span class="p">(</span><span class="n">cvs</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_control_val</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">target_gate</span><span class="o">=</span><span class="n">cirq</span><span class="o">.</span><span class="n">Z</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">sign_more_controlled_Z</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="n">controls</span><span class="o">=</span><span class="n">control_bits</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">sign_qb</span><span class="p">)</span>

        <span class="c1">#################################### full uncompute ####################################</span>

        <span class="c1">## undo controlled rotations</span>
        <span class="k">yield</span> <span class="n">controlled_rotations</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="n">angle_data</span><span class="o">=</span><span class="n">rotations</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">target_down</span><span class="p">,</span><span class="n">phi</span><span class="o">=</span><span class="n">phase_gradient_state</span><span class="p">)</span>

        <span class="c1">## undo givens qrom using measurement based uncompute</span>
        <span class="k">yield</span> <span class="n">qrom_rotations</span><span class="o">.</span><span class="n">measurement_uncompute</span><span class="p">(</span><span class="n">selection</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">zero_padding</span><span class="p">)</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">p_reg</span><span class="p">),</span><span class="n">data</span><span class="o">=</span><span class="n">rotations</span><span class="p">,</span><span class="n">measurement_key</span><span class="o">=</span><span class="s1">&#39;second_qrom_data_measurement&#39;</span><span class="p">)</span> 

        <span class="c1">## undo prepare system registers</span>
        <span class="k">yield</span> <span class="n">qt</span><span class="o">.</span><span class="n">bloqs</span><span class="o">.</span><span class="n">basic_gates</span><span class="o">.</span><span class="n">swap</span><span class="o">.</span><span class="n">CSwap</span><span class="o">.</span><span class="n">make_on</span><span class="p">(</span><span class="n">ctrl</span><span class="o">=</span><span class="n">spin_select</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">target_down</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">target_up</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">cirq</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="o">*</span><span class="n">spin_select</span><span class="p">)</span>

        <span class="c1">## undo contiguous register addition</span>
        <span class="k">yield</span> <span class="n">cirq</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">bloqs</span><span class="o">.</span><span class="n">arithmetic</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">a_dtype</span><span class="o">=</span><span class="n">QUInt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nLXi</span><span class="p">))</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">zero_padding</span><span class="p">)</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">p_reg</span><span class="p">)))</span>

        <span class="c1">## undo InnerPrepare</span>
        <span class="k">yield</span> <span class="n">cirq</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">In_prep_l_2b</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="o">**</span><span class="n">quregs</span><span class="p">))</span>

        <span class="c1">## undo In_l - data_l</span>
        <span class="k">yield</span> <span class="n">qrom_gate</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="n">selection</span><span class="o">=</span><span class="n">l_reg</span><span class="p">,</span><span class="n">target0_</span><span class="o">=</span><span class="n">l_neq_0</span><span class="p">,</span><span class="n">target1_</span><span class="o">=</span><span class="n">Xi_l</span><span class="p">,</span><span class="n">target2_</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span><span class="n">target3_</span><span class="o">=</span><span class="n">rot</span><span class="p">)</span>

        <span class="c1">## undo OuterPrepare</span>
        <span class="k">yield</span> <span class="n">cirq</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">outer_prep</span><span class="o">.</span><span class="n">on_registers</span><span class="p">(</span><span class="n">success</span><span class="o">=</span><span class="n">succ_l</span><span class="p">,</span><span class="n">selection</span><span class="o">=</span><span class="n">l_reg</span><span class="p">,</span><span class="n">sigma_mu</span><span class="o">=</span><span class="n">sigma_l</span><span class="p">,</span><span class="n">alt</span><span class="o">=</span><span class="n">alt_l</span><span class="p">,</span><span class="n">keep</span><span class="o">=</span><span class="n">keep_l</span><span class="p">,</span><span class="n">less_than_equal</span><span class="o">=</span><span class="n">less_than_equal_ancilla</span><span class="p">))</span></div>
</div>


<div class="viewcode-block" id="approx_angles_as_ints_with_br_bits">
<a class="viewcode-back" href="../../../../docs/_modules/src.pyLIQTR.BlockEncodings.html#src.pyLIQTR.BlockEncodings.DoubleFactorized.approx_angles_as_ints_with_br_bits">[docs]</a>
<span class="k">def</span> <span class="nf">approx_angles_as_ints_with_br_bits</span><span class="p">(</span><span class="n">angles</span><span class="p">:</span><span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span><span class="n">br</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">angles_normalized</span> <span class="o">=</span> <span class="n">angles</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span> <span class="mi">1</span>
    <span class="n">approx_ints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">angle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">angles_normalized</span><span class="p">):</span>
        <span class="n">binary_angle</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">iter_bits_fixed_point</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="n">br</span><span class="p">,</span><span class="n">signed</span><span class="o">=</span><span class="kc">False</span><span class="p">)]</span>
        <span class="n">approx_ints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">binary_angle</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">approx_ints</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, MIT Lincoln Laboratory.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>