

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>src.pyLIQTR.gate_decomp package &mdash; pyLIQTR 1.3.4 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/jupyter-sphinx.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/thebelab.css" />

  
    <link rel="shortcut icon" href="../../_static/pyliqtr_logo.png"/>
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=e358f374"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/thebelab-helper.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            pyLIQTR
              <img src="../../_static/pyliqtr_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../document.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release.html">Release strategy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../debugger.html">Debugger</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../best_practice.html">Best Practices</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">pyLIQTR API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api-internal.html">Internal API reference, for users customizing behavior</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../_autosummary/pyLIQTR.html">pyLIQTR</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pyLIQTR</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">src.pyLIQTR.gate_decomp package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/docs/_modules/src.pyLIQTR.gate_decomp.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="src-pyliqtr-gate-decomp-package">
<h1>src.pyLIQTR.gate_decomp package<a class="headerlink" href="#src-pyliqtr-gate-decomp-package" title="Link to this heading"></a></h1>
<section id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Link to this heading"></a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html">src.pyLIQTR.gate_decomp.tests package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#module-src.pyLIQTR.gate_decomp.tests.benchmarks">src.pyLIQTR.gate_decomp.tests.benchmarks module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.benchmarks.benchmark_gse_circuit"><code class="docutils literal notranslate"><span class="pre">benchmark_gse_circuit()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.benchmarks.benchmark_random_angles"><code class="docutils literal notranslate"><span class="pre">benchmark_random_angles()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.benchmarks.estimate_t_count_direct"><code class="docutils literal notranslate"><span class="pre">estimate_t_count_direct()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.benchmarks.estimate_t_count_fallback"><code class="docutils literal notranslate"><span class="pre">estimate_t_count_fallback()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.benchmarks.main"><code class="docutils literal notranslate"><span class="pre">main()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#module-src.pyLIQTR.gate_decomp.tests.conftest">src.pyLIQTR.gate_decomp.tests.conftest module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.conftest.test_circuit_4_qubits"><code class="docutils literal notranslate"><span class="pre">test_circuit_4_qubits()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.conftest.test_circuit_no_rz"><code class="docutils literal notranslate"><span class="pre">test_circuit_no_rz()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#module-src.pyLIQTR.gate_decomp.tests.test_cirq_transformers">src.pyLIQTR.gate_decomp.tests.test_cirq_transformers module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.precision_is_valid"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.precision_is_valid()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.pytestmark"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.pytestmark</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.setUp"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.setUp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_XPow_gates"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_XPow_gates()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_accuracy_issue"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_accuracy_issue()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_determine_gate_precision_circuit_precision_none"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_determine_gate_precision_circuit_precision_none()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_determine_gate_precision_no_rotational_gates"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_determine_gate_precision_no_rotational_gates()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_determine_gate_precision_only_circuit_precision"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_determine_gate_precision_only_circuit_precision()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_determine_gate_precision_only_gate_precision"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_determine_gate_precision_only_gate_precision()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_determine_gate_precision_valid_params"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_determine_gate_precision_valid_params()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_get_approx_t_depth"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_get_approx_t_depth()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_gse_circuit"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_gse_circuit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_multi_axis_rotation_prec10"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_multi_axis_rotation_prec10()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_multi_axis_rotation_prec13"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_multi_axis_rotation_prec13()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_multiple_decomp_rotations_to_qasm"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_multiple_decomp_rotations_to_qasm()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_num_rotation_gates1"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_num_rotation_gates1()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_pi_rots"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_pi_rots()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_profile_prec10"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_profile_prec10()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_profile_prec15"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_profile_prec15()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_qsp_circuit"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_qsp_circuit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_random_decomp1"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_random_decomp1()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_random_decomp2"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_random_decomp2()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_rx_decomp_inverse_gate"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_rx_decomp_inverse_gate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_rx_decomp_to_qasm"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_rx_decomp_to_qasm()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_ry_decomp_to_qasm"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_ry_decomp_to_qasm()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_rz_decomp1"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_rz_decomp1()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_rz_decomp2"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_rz_decomp2()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_rz_decomp_circuit2qasm"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_rz_decomp_circuit2qasm()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_rz_decomp_qsp_circuit"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_rz_decomp_qsp_circuit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_rz_decomp_to_qasm"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_rz_decomp_to_qasm()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_rz_decomp_w_classical_controls"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_rz_decomp_w_classical_controls()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_single_qubit_x_rotation"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_single_qubit_x_rotation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_single_qubit_y_rotation"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_single_qubit_y_rotation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.TestCirqTransforms.test_single_qubit_z_rotation"><code class="docutils literal notranslate"><span class="pre">TestCirqTransforms.test_single_qubit_z_rotation()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_cirq_transformers.random"><code class="docutils literal notranslate"><span class="pre">random()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#module-src.pyLIQTR.gate_decomp.tests.test_exact_decomp">src.pyLIQTR.gate_decomp.tests.test_exact_decomp module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_exact_decomp.TestExactDecomp"><code class="docutils literal notranslate"><span class="pre">TestExactDecomp</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_exact_decomp.TestExactDecomp.test_compressed_rep1"><code class="docutils literal notranslate"><span class="pre">TestExactDecomp.test_compressed_rep1()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_exact_decomp.TestExactDecomp.test_compressed_rep2"><code class="docutils literal notranslate"><span class="pre">TestExactDecomp.test_compressed_rep2()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_exact_decomp.TestExactDecomp.test_exact_decomp_fallback_prec10"><code class="docutils literal notranslate"><span class="pre">TestExactDecomp.test_exact_decomp_fallback_prec10()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_exact_decomp.TestExactDecomp.test_exact_decomp_fallback_prec20"><code class="docutils literal notranslate"><span class="pre">TestExactDecomp.test_exact_decomp_fallback_prec20()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_exact_decomp.TestExactDecomp.test_exact_decomp_fallback_prec30"><code class="docutils literal notranslate"><span class="pre">TestExactDecomp.test_exact_decomp_fallback_prec30()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_exact_decomp.TestExactDecomp.test_exact_decomp_fallback_prec40"><code class="docutils literal notranslate"><span class="pre">TestExactDecomp.test_exact_decomp_fallback_prec40()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_exact_decomp.TestExactDecomp.test_exact_decomp_fallback_prec50"><code class="docutils literal notranslate"><span class="pre">TestExactDecomp.test_exact_decomp_fallback_prec50()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_exact_decomp.TestExactDecomp.test_exact_decomp_prec10"><code class="docutils literal notranslate"><span class="pre">TestExactDecomp.test_exact_decomp_prec10()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_exact_decomp.TestExactDecomp.test_exact_decomp_prec20"><code class="docutils literal notranslate"><span class="pre">TestExactDecomp.test_exact_decomp_prec20()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_exact_decomp.TestExactDecomp.test_exact_decomp_prec30"><code class="docutils literal notranslate"><span class="pre">TestExactDecomp.test_exact_decomp_prec30()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_exact_decomp.TestExactDecomp.test_exact_decomp_prec40"><code class="docutils literal notranslate"><span class="pre">TestExactDecomp.test_exact_decomp_prec40()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_exact_decomp.TestExactDecomp.test_rand_angles_prec50"><code class="docutils literal notranslate"><span class="pre">TestExactDecomp.test_rand_angles_prec50()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#module-src.pyLIQTR.gate_decomp.tests.test_matrices">src.pyLIQTR.gate_decomp.tests.test_matrices module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_matrices.TestMatrices"><code class="docutils literal notranslate"><span class="pre">TestMatrices</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_matrices.TestMatrices.test_convert_H"><code class="docutils literal notranslate"><span class="pre">TestMatrices.test_convert_H()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_matrices.TestMatrices.test_convert_HT"><code class="docutils literal notranslate"><span class="pre">TestMatrices.test_convert_HT()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_matrices.TestMatrices.test_convert_S"><code class="docutils literal notranslate"><span class="pre">TestMatrices.test_convert_S()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_matrices.TestMatrices.test_convert_T"><code class="docutils literal notranslate"><span class="pre">TestMatrices.test_convert_T()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_matrices.TestMatrices.test_convert_T2"><code class="docutils literal notranslate"><span class="pre">TestMatrices.test_convert_T2()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_matrices.TestMatrices.test_convert_complicated"><code class="docutils literal notranslate"><span class="pre">TestMatrices.test_convert_complicated()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_matrices.TestMatrices.test_mult_MATDOMEGA_1"><code class="docutils literal notranslate"><span class="pre">TestMatrices.test_mult_MATDOMEGA_1()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_matrices.TestMatrices.test_mult_MATDOMEGA_2"><code class="docutils literal notranslate"><span class="pre">TestMatrices.test_mult_MATDOMEGA_2()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_matrices.TestMatrices.test_mult_SO3_1"><code class="docutils literal notranslate"><span class="pre">TestMatrices.test_mult_SO3_1()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_matrices.TestMatrices.test_mult_SO3_2"><code class="docutils literal notranslate"><span class="pre">TestMatrices.test_mult_SO3_2()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_matrices.TestMatrices.test_mult_SO3_3"><code class="docutils literal notranslate"><span class="pre">TestMatrices.test_mult_SO3_3()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#module-src.pyLIQTR.gate_decomp.tests.test_point_enumeration">src.pyLIQTR.gate_decomp.tests.test_point_enumeration module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_A_op"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_A_op()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_B_op"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_B_op()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_K_op"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_K_op()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_R_op"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_R_op()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_find_bounding_ellipse"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_find_bounding_ellipse()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_find_e_and_z"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_find_e_and_z()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_find_k_1"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_find_k_1()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_find_k_2"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_find_k_2()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_find_k_3"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_find_k_3()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_find_k_4"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_find_k_4()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_find_k_5"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_find_k_5()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_find_u_candidate_1"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_find_u_candidate_1()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_find_u_candidate_2"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_find_u_candidate_2()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_find_u_candidate_3"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_find_u_candidate_3()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_find_u_candidate_4"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_find_u_candidate_4()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_one_dim_grid_problem_rand"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_one_dim_grid_problem_rand()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_reduce_skew_extra_1"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_reduce_skew_extra_1()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_reduce_skew_large_bias1"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_reduce_skew_large_bias1()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_reduce_skew_large_bias2"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_reduce_skew_large_bias2()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_scaled_one_dim_grid_problem_1"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_scaled_one_dim_grid_problem_1()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_scaled_one_dim_grid_problem_2"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_scaled_one_dim_grid_problem_2()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_scaled_one_dim_grid_problem_3"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_scaled_one_dim_grid_problem_3()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_scaled_one_dim_grid_problem_4"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_scaled_one_dim_grid_problem_4()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_shift_operator"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_shift_operator()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_solve_one_dim_grid_problem_1"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_solve_one_dim_grid_problem_1()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_solve_one_dim_grid_problem_2"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_solve_one_dim_grid_problem_2()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_solve_one_dim_grid_problem_3"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_solve_one_dim_grid_problem_3()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_solve_one_dim_grid_problem_4"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_solve_one_dim_grid_problem_4()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_solve_one_dim_grid_problem_5"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_solve_one_dim_grid_problem_5()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_solve_one_dim_grid_problem_6"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_solve_one_dim_grid_problem_6()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_solve_one_dim_grid_problem_tmp"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_solve_one_dim_grid_problem_tmp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_solve_two_dim_grid_problem_ellipse"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_solve_two_dim_grid_problem_ellipse()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_two_dim_upright_rectangle1"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_two_dim_upright_rectangle1()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_point_enumeration.TestApproximationFunctions.test_two_dim_upright_rectangle2"><code class="docutils literal notranslate"><span class="pre">TestApproximationFunctions.test_two_dim_upright_rectangle2()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#module-src.pyLIQTR.gate_decomp.tests.test_solve_diophantine">src.pyLIQTR.gate_decomp.tests.test_solve_diophantine module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_solve_diophantine.TestFactoringFunctions"><code class="docutils literal notranslate"><span class="pre">TestFactoringFunctions</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_solve_diophantine.TestFactoringFunctions.test_factor1"><code class="docutils literal notranslate"><span class="pre">TestFactoringFunctions.test_factor1()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_solve_diophantine.TestFactoringFunctions.test_factor2"><code class="docutils literal notranslate"><span class="pre">TestFactoringFunctions.test_factor2()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_solve_diophantine.TestFactoringFunctions.test_modular_square_root1"><code class="docutils literal notranslate"><span class="pre">TestFactoringFunctions.test_modular_square_root1()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_solve_diophantine.TestFactoringFunctions.test_modular_square_root2"><code class="docutils literal notranslate"><span class="pre">TestFactoringFunctions.test_modular_square_root2()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_solve_diophantine.TestFactoringFunctions.test_modular_square_root3"><code class="docutils literal notranslate"><span class="pre">TestFactoringFunctions.test_modular_square_root3()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_solve_diophantine.TestFactoringFunctions.test_modular_square_root4"><code class="docutils literal notranslate"><span class="pre">TestFactoringFunctions.test_modular_square_root4()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#src.pyLIQTR.gate_decomp.tests.test_solve_diophantine.TestFactoringFunctions.test_modular_square_root5"><code class="docutils literal notranslate"><span class="pre">TestFactoringFunctions.test_modular_square_root5()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="src.pyLIQTR.gate_decomp.tests.html#module-src.pyLIQTR.gate_decomp.tests">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</section>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading"></a></h2>
</section>
<section id="module-src.pyLIQTR.gate_decomp.cirq_transforms">
<span id="src-pyliqtr-gate-decomp-cirq-transforms-module"></span><h2>src.pyLIQTR.gate_decomp.cirq_transforms module<a class="headerlink" href="#module-src.pyLIQTR.gate_decomp.cirq_transforms" title="Link to this heading"></a></h2>
<p>DISTRIBUTION STATEMENT A. Approved for public release. Distribution is unlimited.</p>
<p>This material is based upon work supported by the Under Secretary of Defense for
Research and Engineering under Air Force Contract No. FA8702-15-D-0001. Any opinions,
findings, conclusions or recommendations expressed in this material are those of the
author(s) and do not necessarily reflect the views of the Under Secretary of Defense
for Research and Engineering.</p>
<p>© 2022 Massachusetts Institute of Technology.</p>
<p>The software/firmware is provided to you on an As-Is basis</p>
<p>Delivered to the U.S. Government with Unlimited Rights, as defined in DFARS Part
252.227-7013 or 7014 (Feb 2014). Notwithstanding any copyright notice, U.S. Government
rights in this work are defined by DFARS 252.227-7013 or DFARS 252.227-7014 as detailed
above. Use of this work other than as specifically authorized by the U.S. Government
may violate any copyrights that exist in this work.</p>
<p>Transformers for decomposing single qubit rotations in cirq circuits into
Clifford+T gates using the approximation method described in arXiv:1403.2975v3,
and an exact synthesis algorithm based on the Matsumoto-Amano normal form (see
arXiv:0806.3834, arXiv:1312.6584, and https://www.cs.umd.edu/~amchilds/qa/qa.pdf
Section 3)</p>
<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.cirq_transforms.clifford_plus_t_direct_transform">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.cirq_transforms.</span></span><span class="sig-name descname"><span class="pre">clifford_plus_t_direct_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">circuit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">AbstractCircuit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gate_precision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#float" title="(in Python v3.8)"><span class="pre">float</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/constants.html#None" title="(in Python v3.8)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">circuit_precision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#float" title="(in Python v3.8)"><span class="pre">float</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/constants.html#None" title="(in Python v3.8)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_rotation_gates</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/constants.html#None" title="(in Python v3.8)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_rotation_decomp_gates</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_random_decomp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warn_if_not_decomposed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">AbstractCircuit</span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/cirq_transforms.html#clifford_plus_t_direct_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.cirq_transforms.clifford_plus_t_direct_transform" title="Link to this definition"></a></dt>
<dd><p>Decompose every single qubit unitary in the circuit into a Clifford+T
approximation.</p>
<section id="setting-the-precision">
<h3>Setting the Precision<a class="headerlink" href="#setting-the-precision" title="Link to this heading"></a></h3>
<p>There are two ways to specify the desired approximation error due to decomposition:
<cite>gate_precision</cite> and <cite>circuit_precision</cite>. If <cite>circuit_precision</cite> is not None, then
each gate will have an approximation error bounded by <cite>circuit_precision</cite> divided by
the number of rotation gates, so that the approximation error of the entire circuit
will be bounded by <cite>circuit_precision</cite>. If <cite>circuit_precision</cite> is None, and
<cite>gate_precision</cite> is not, then each rotation gate in the circuit will be replaced by
an approximation upper bounded by <cite>gate_precision</cite> in the operator norm.</p>
</section>
<section id="output-circuit">
<h3>Output Circuit<a class="headerlink" href="#output-circuit" title="Link to this heading"></a></h3>
<p>There are also two ways in which the circuit can be output, which is specificed via the
<cite>use_rotation_decomp_gates</cite> parameter (<cite>False</cite> by default). In the default mode, this function
returns the fully decomposed circuit, with all of the single qubit rotations replaced with
Clifford and T gates.</p>
<p>When <cite>use_rotation_decomp_gates</cite> is set to <cite>True</cite>, the single qubit rotation gates in
the circuit get replaced with custom gates (<cite>r&lt;x/y/z&gt;_decomp</cite>) that know their
Clifford+T decomposition, and can be queried for their number of T gates. Users can
obtain a fully decomposed circuit using <cite>cirq.decompose</cite>, for example, if <cite>circuit</cite>
is a <cite>cirq.Circuit</cite> containing the custom rotation gates, they can be expanding via</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expanded_circuit</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">expand_composite</span><span class="p">(</span>
<span class="go">        circuit, no_decomp=lambda g: g.gate in [cirq.H]</span>
<span class="go">    )</span>
</pre></div>
</div>
<p>Note that we have to specify that we do not want H gates to be decomposed.</p>
<dl class="field-list simple">
<dt class="field-odd">param circuit<span class="colon">:</span></dt>
<dd class="field-odd"><p>The circuit to be decomposed. Currently, the circuit can only use the following
gates:
- Multi-qubit gates. CCX and CCZ gates are decomposed into Clifford+T exactly.
The rest are ignored by the decomposition function.
- Single qubit gates from the list clifford_plus_T_gates above (ignored by the
decomposition function.
- Rx, Ry, and Rz gates, which are decomposed into clifford+T approximations.</p>
</dd>
<dt class="field-even">type circuit<span class="colon">:</span></dt>
<dd class="field-even"><p>cirq.AbstractCircuit</p>
</dd>
<dt class="field-odd">param gate_precision<span class="colon">:</span></dt>
<dd class="field-odd"><p>Used to determine the maximum approximation error for each gate decomposition.
If given an int, the decomposition returned by the function will be within a
distance of 10^{-precision} of the given rotation in the operator norm, whereas
if given a float the max error in the operator norm will simply be
gate_precision.</p>
</dd>
<dt class="field-even">type gate_precision<span class="colon">:</span></dt>
<dd class="field-even"><p>Union[int, float, None]</p>
</dd>
<dt class="field-odd">param circuit_precision<span class="colon">:</span></dt>
<dd class="field-odd"><p>If not None, the approximation error for each gate will be bounded by either
<cite>circuit_precision</cite> divided by the number of rotation gates (if given a float),
or 10^{-circuit_precision} (if given an int). Note that this requires doing an
initial pass over the circuit to count the number of rotation gates, unless
<cite>num_rotation_gates</cite> is specified by the caller.</p>
</dd>
<dt class="field-even">type circuit_precision<span class="colon">:</span></dt>
<dd class="field-even"><p>Union[int, float, None]</p>
</dd>
<dt class="field-odd">param num_rotation_gates<span class="colon">:</span></dt>
<dd class="field-odd"><p>The number of rotation gates in the circuit. If known, pass this in as it will cut down
on the amount of execution time, particularly if the number of gates is very large.</p>
</dd>
<dt class="field-even">type num_rotation_gates<span class="colon">:</span></dt>
<dd class="field-even"><p>Union[int, None]:</p>
</dd>
<dt class="field-odd">param use_rotation_decomp_gates<span class="colon">:</span></dt>
<dd class="field-odd"><p>If true, replace <cite>cirq.r&lt;x/y/z&gt;</cite> gates with
<cite>pyLIQTR.gate_decomp.r&lt;x/y/z&gt;_decomp</cite> gates, which can be expanded later into a
Clifford+T circuit. If false, return a fully expanded Clifford+T circuit.</p>
</dd>
<dt class="field-even">type use_rotation_decomp_gates<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
<dt class="field-odd">param use_random_decomp<span class="colon">:</span></dt>
<dd class="field-odd"><p>If true, rotations will be “decomposed” into randomly selected Clifford+T
sequences, with the length of the sequence depending on the given precision.
For a precision of ε, the T count is sampled from a normal distribution with
a mean of 3.02 * log2(1/ε) + 0.77 and a standard deviation of 2.06 (these
numbers were obtained from decomposing 1000 random angles at varying
precisions).</p>
</dd>
<dt class="field-even">type use_random_decomp<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
<dt class="field-odd">param warn_if_not_decomposed<span class="colon">:</span></dt>
<dd class="field-odd"><p>If true, raises a warning when the circuit includes a non-clifford+T gate that
is not an X, Y, or Z rotation. Such gates are not decomposed.</p>
</dd>
<dt class="field-even">type warn_if_not_decomposed<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
<dt class="field-odd">returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A new circuit where the single qubit rotations have been replaced by approximations
using the gates listed in the list clifford_plus_T_ops above</p>
</dd>
<dt class="field-even">rtype<span class="colon">:</span></dt>
<dd class="field-even"><p>cirq.AbstractCircuit</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.cirq_transforms.count_rotation_gates">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.cirq_transforms.</span></span><span class="sig-name descname"><span class="pre">count_rotation_gates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">circuit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">AbstractCircuit</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/cirq_transforms.html#count_rotation_gates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.cirq_transforms.count_rotation_gates" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.cirq_transforms.decompose_cirq_directCpT">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.cirq_transforms.</span></span><span class="sig-name descname"><span class="pre">decompose_cirq_directCpT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rev</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/cirq_transforms.html#decompose_cirq_directCpT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.cirq_transforms.decompose_cirq_directCpT" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.cirq_transforms.decompose_diagonal_cirq">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.cirq_transforms.</span></span><span class="sig-name descname"><span class="pre">decompose_diagonal_cirq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">angle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#float" title="(in Python v3.8)"><span class="pre">float</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Qid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classical_control</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/constants.html#None" title="(in Python v3.8)"><span class="pre">None</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.FrozenSet" title="(in Python v3.8)"><span class="pre">FrozenSet</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Condition</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_random_decomp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Iterable" title="(in Python v3.8)"><span class="pre">Iterable</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Operation</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/cirq_transforms.html#decompose_diagonal_cirq"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.cirq_transforms.decompose_diagonal_cirq" title="Link to this definition"></a></dt>
<dd><p>Decompose an rz rotation into cirq gates</p>
<p>If the original operation was classically controlled, all of the gates from the
decomposition will be classically controlled as well.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.cirq_transforms.determine_gate_precision">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.cirq_transforms.</span></span><span class="sig-name descname"><span class="pre">determine_gate_precision</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">circuit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">AbstractCircuit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gate_precision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#float" title="(in Python v3.8)"><span class="pre">float</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/constants.html#None" title="(in Python v3.8)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">circuit_precision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#float" title="(in Python v3.8)"><span class="pre">float</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/constants.html#None" title="(in Python v3.8)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_rotation_gates</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/constants.html#None" title="(in Python v3.8)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#float" title="(in Python v3.8)"><span class="pre">float</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/cirq_transforms.html#determine_gate_precision"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.cirq_transforms.determine_gate_precision" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.cirq_transforms.get_approximate_t_depth">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.cirq_transforms.</span></span><span class="sig-name descname"><span class="pre">get_approximate_t_depth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">circuit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">AbstractCircuit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depthToff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gate_precision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#float" title="(in Python v3.8)"><span class="pre">float</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/constants.html#None" title="(in Python v3.8)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">circuit_precision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#float" title="(in Python v3.8)"><span class="pre">float</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/constants.html#None" title="(in Python v3.8)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/cirq_transforms.html#get_approximate_t_depth"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.cirq_transforms.get_approximate_t_depth" title="Link to this definition"></a></dt>
<dd><p>Get the approximate T depth of a circuit.</p>
<p>This function approximates the T depth of a circuit using the following heuristic:
for each moment in the cirq circuit, it finds the gate with the highest T-count
when decomposed to Clifford+T, and then adds up the the T count from each moment.</p>
<p>Gate T counts are determined as follows:
- Single qubit rotation gate: For a precision of ε, the T count is
3.02 * log2(1/ε) + 0.77 (these numbers were obtained from decomposing 1000 random
angles at varying precisions).
- CCX/CCZ Gates: <cite>depthToff</cite> T gates (7 by default)
- T or T^{dagger}: 1 T gate</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>circuit</strong> (<em>cirq.AbstractCircuit</em>) – The circuit whose T depth will be estimated</p></li>
<li><p><strong>depthToff</strong> (<a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The number of T gates that a CCX or CCZ gate counts as</p></li>
<li><p><strong>gate_precision</strong> (<em>Union</em><em>[</em><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>None</em><em>]</em>) – Used to determine the how many T gates a single qubit rotation counts as.
If given an int, precision used to estimate the gate_count will be
10^{-gate_precision} whereas if given a float the precision will simply be
gate_precision.</p></li>
<li><p><strong>circuit_precision</strong> (<em>Union</em><em>[</em><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>None</em><em>]</em>) – If not None, the precision for each gate will be either <cite>circuit_precision</cite>
divided by the number of rotation gates (if given a float), or
10^{-circuit_precision} divided by the number of rotation gates (if given an
int). Note that this requires doing an initial pass over the circuit to count
the number of rotation gates, unless <cite>num_rotation_gates</cite> is specified by the caller.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.cirq_transforms.get_num_rotation_gates">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.cirq_transforms.</span></span><span class="sig-name descname"><span class="pre">get_num_rotation_gates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">circuit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">AbstractCircuit</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">GeneratorType</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/cirq_transforms.html#get_num_rotation_gates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.cirq_transforms.get_num_rotation_gates" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.cirq_transforms.is_directCpT_gate">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.cirq_transforms.</span></span><span class="sig-name descname"><span class="pre">is_directCpT_gate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">op</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Operation</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)"><span class="pre">bool</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/cirq_transforms.html#is_directCpT_gate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.cirq_transforms.is_directCpT_gate" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.cirq_transforms.is_filtered_gate">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.cirq_transforms.</span></span><span class="sig-name descname"><span class="pre">is_filtered_gate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">op</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Operation</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)"><span class="pre">bool</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/cirq_transforms.html#is_filtered_gate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.cirq_transforms.is_filtered_gate" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.cirq_transforms.is_gate_clifford_plus_T">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.cirq_transforms.</span></span><span class="sig-name descname"><span class="pre">is_gate_clifford_plus_T</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">op</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Operation</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)"><span class="pre">bool</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/cirq_transforms.html#is_gate_clifford_plus_T"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.cirq_transforms.is_gate_clifford_plus_T" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.cirq_transforms.parse_and_reconstruct">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.cirq_transforms.</span></span><span class="sig-name descname"><span class="pre">parse_and_reconstruct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">line</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/cirq_transforms.html#parse_and_reconstruct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.cirq_transforms.parse_and_reconstruct" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.cirq_transforms.parse_gate">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.cirq_transforms.</span></span><span class="sig-name descname"><span class="pre">parse_gate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gate</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Gate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warn_if_not_decomposed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.List" title="(in Python v3.8)"><span class="pre">List</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Tuple" title="(in Python v3.8)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3.8/library/stdtypes.html#str" title="(in Python v3.8)"><span class="pre">str</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#float" title="(in Python v3.8)"><span class="pre">float</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/cirq_transforms.html#parse_gate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.cirq_transforms.parse_gate" title="Link to this definition"></a></dt>
<dd><p>Parse cirq gate into something that can be decomposed</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>gate</strong> (<em>cirq.Gate</em>) – The gate to be decomposed. Currently only supports for Rx, Ry, and Rz gates.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of gates represented by a tuple. The tuple elements are
- str: rotation axis (x/y/z)
- float: rotation angle</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>List[Tuple[<a class="reference external" href="https://docs.python.org/3.8/library/stdtypes.html#str" title="(in Python v3.8)">str</a>, <a class="reference external" href="https://docs.python.org/3.8/library/functions.html#float" title="(in Python v3.8)">float</a>]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.cirq_transforms.random_decomp">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.cirq_transforms.</span></span><span class="sig-name descname"><span class="pre">random_decomp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/cirq_transforms.html#random_decomp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.cirq_transforms.random_decomp" title="Link to this definition"></a></dt>
<dd></dd></dl>

</section>
<section id="module-src.pyLIQTR.gate_decomp.clifford_gates">
<span id="src-pyliqtr-gate-decomp-clifford-gates-module"></span><h2>src.pyLIQTR.gate_decomp.clifford_gates module<a class="headerlink" href="#module-src.pyLIQTR.gate_decomp.clifford_gates" title="Link to this heading"></a></h2>
<p>DISTRIBUTION STATEMENT A. Approved for public release. Distribution is unlimited.</p>
<p>This material is based upon work supported by the Under Secretary of Defense for
Research and Engineering under Air Force Contract No. FA8702-15-D-0001. Any opinions,
findings, conclusions or recommendations expressed in this material are those of the
author(s) and do not necessarily reflect the views of the Under Secretary of Defense
for Research and Engineering.</p>
<p>© 2022 Massachusetts Institute of Technology.</p>
<p>The software/firmware is provided to you on an As-Is basis</p>
<p>Delivered to the U.S. Government with Unlimited Rights, as defined in DFARS Part
252.227-7013 or 7014 (Feb 2014). Notwithstanding any copyright notice, U.S. Government
rights in this work are defined by DFARS 252.227-7013 or DFARS 252.227-7014 as detailed
above. Use of this work other than as specifically authorized by the U.S. Government
may violate any copyrights that exist in this work.</p>
<p>Get a list of all single qubit clifford operators (up to phase)</p>
<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.clifford_gates.create_operator_op">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.clifford_gates.</span></span><span class="sig-name descname"><span class="pre">create_operator_op</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clifford_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/stdtypes.html#str" title="(in Python v3.8)"><span class="pre">str</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.matrices.SO3" title="src.pyLIQTR.gate_decomp.matrices.SO3"><span class="pre">SO3</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/clifford_gates.html#create_operator_op"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.clifford_gates.create_operator_op" title="Link to this definition"></a></dt>
<dd></dd></dl>

</section>
<section id="module-src.pyLIQTR.gate_decomp.ellipse">
<span id="src-pyliqtr-gate-decomp-ellipse-module"></span><h2>src.pyLIQTR.gate_decomp.ellipse module<a class="headerlink" href="#module-src.pyLIQTR.gate_decomp.ellipse" title="Link to this heading"></a></h2>
<p>Copyright (c) 2024 Massachusetts Institute of Technology
SPDX-License-Identifier: BSD-2-Clause</p>
<dl class="py class">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.ellipse.Ellipse">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.ellipse.</span></span><span class="sig-name descname"><span class="pre">Ellipse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">mpfr('0.0')</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">mpfr('0.0')</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">semi_major</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/constants.html#None" title="(in Python v3.8)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">semi_minor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/constants.html#None" title="(in Python v3.8)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/ellipse.html#Ellipse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3.8/library/functions.html#object" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A class representing ellipses as positive definite matrices</p>
<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.ellipse.Ellipse.compute_x_points">
<span class="sig-name descname"><span class="pre">compute_x_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Tuple" title="(in Python v3.8)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><span class="pre">mpfr</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">mpfr</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/ellipse.html#Ellipse.compute_x_points"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse.compute_x_points" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.ellipse.Ellipse.compute_y_points">
<span class="sig-name descname"><span class="pre">compute_y_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Tuple" title="(in Python v3.8)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><span class="pre">mpfr</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">mpfr</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/ellipse.html#Ellipse.compute_y_points"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse.compute_y_points" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.ellipse.Ellipse.contains">
<span class="sig-name descname"><span class="pre">contains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)"><span class="pre">bool</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/ellipse.html#Ellipse.contains"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse.contains" title="Link to this definition"></a></dt>
<dd><p>Determine if the ellipse contains the point (x, y)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.ellipse.Ellipse.descriminant">
<span class="sig-name descname"><span class="pre">descriminant</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">mpfr</span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/ellipse.html#Ellipse.descriminant"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse.descriminant" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.ellipse.Ellipse.determinant">
<span class="sig-name descname"><span class="pre">determinant</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">mpfr</span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/ellipse.html#Ellipse.determinant"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse.determinant" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.ellipse.Ellipse.from_axes">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_axes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">semi_major</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">semi_minor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/ellipse.html#Ellipse.from_axes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse.from_axes" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.ellipse.Ellipse.is_positive_semi_definite">
<span class="sig-name descname"><span class="pre">is_positive_semi_definite</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)"><span class="pre">bool</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/ellipse.html#Ellipse.is_positive_semi_definite"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse.is_positive_semi_definite" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.ellipse.calculate_bias">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.ellipse.</span></span><span class="sig-name descname"><span class="pre">calculate_bias</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="src.pyLIQTR.gate_decomp.ellipse.Ellipse"><span class="pre">Ellipse</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="src.pyLIQTR.gate_decomp.ellipse.Ellipse"><span class="pre">Ellipse</span></a></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/ellipse.html#calculate_bias"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.ellipse.calculate_bias" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.ellipse.calculate_skew">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.ellipse.</span></span><span class="sig-name descname"><span class="pre">calculate_skew</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="src.pyLIQTR.gate_decomp.ellipse.Ellipse"><span class="pre">Ellipse</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="src.pyLIQTR.gate_decomp.ellipse.Ellipse"><span class="pre">Ellipse</span></a></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/ellipse.html#calculate_skew"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.ellipse.calculate_skew" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.ellipse.force_det_one">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.ellipse.</span></span><span class="sig-name descname"><span class="pre">force_det_one</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="src.pyLIQTR.gate_decomp.ellipse.Ellipse"><span class="pre">Ellipse</span></a></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/ellipse.html#force_det_one"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.ellipse.force_det_one" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.ellipse.scale_ellipse">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.ellipse.</span></span><span class="sig-name descname"><span class="pre">scale_ellipse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="src.pyLIQTR.gate_decomp.ellipse.Ellipse"><span class="pre">Ellipse</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/ellipse.html#scale_ellipse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.ellipse.scale_ellipse" title="Link to this definition"></a></dt>
<dd></dd></dl>

</section>
<section id="module-src.pyLIQTR.gate_decomp.exact_decomp">
<span id="src-pyliqtr-gate-decomp-exact-decomp-module"></span><h2>src.pyLIQTR.gate_decomp.exact_decomp module<a class="headerlink" href="#module-src.pyLIQTR.gate_decomp.exact_decomp" title="Link to this heading"></a></h2>
<p>DISTRIBUTION STATEMENT A. Approved for public release. Distribution is unlimited.</p>
<p>This material is based upon work supported by the Under Secretary of Defense for
Research and Engineering under Air Force Contract No. FA8702-15-D-0001. Any opinions,
findings, conclusions or recommendations expressed in this material are those of the
author(s) and do not necessarily reflect the views of the Under Secretary of Defense
for Research and Engineering.</p>
<p>© 2022 Massachusetts Institute of Technology.</p>
<p>The software/firmware is provided to you on an As-Is basis</p>
<p>Delivered to the U.S. Government with Unlimited Rights, as defined in DFARS Part
252.227-7013 or 7014 (Feb 2014). Notwithstanding any copyright notice, U.S. Government
rights in this work are defined by DFARS 252.227-7013 or DFARS 252.227-7014 as detailed
above. Use of this work other than as specifically authorized by the U.S. Government
may violate any copyrights that exist in this work.</p>
<p>Functions for performing exact decomposition of single qubit unitary matrices with
entries from the ring D[ω] over the Clifford+T gateset. Makes use of the Matsumoto-
Amano normal form for single qubit Clifford+T operators [1,2,3]
[1] - arXiv:0806.3834
[2] - arXiv:1312.6584
[3] - https://www.cs.umd.edu/~amchilds/qa/qa.pdf Section 3</p>
<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.exact_decomp.are_equivalent">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.exact_decomp.</span></span><span class="sig-name descname"><span class="pre">are_equivalent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gates</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/stdtypes.html#str" title="(in Python v3.8)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA" title="src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA"><span class="pre">MAT_D_OMEGA</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)"><span class="pre">bool</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/exact_decomp.html#are_equivalent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.exact_decomp.are_equivalent" title="Link to this definition"></a></dt>
<dd><p>Verify that a given gate sequence is exactly equal to the unitary U</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gates</strong> (<a class="reference external" href="https://docs.python.org/3.8/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – A string of representing a circuit. Gates can be
- H: Hadamard
- S: Phase gate (√Z gate)
- Sd: Adjoint of the phase gate
- T: T gate (√S gate)
- X: Pauli X
- Y: Pauli Y
- Z: Pauli Z</p></li>
<li><p><strong>U</strong> (<a class="reference internal" href="#src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA" title="src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA"><em>MAT_D_OMEGA</em></a>) – The matrix that the circuit represented by gates should be equivalent to</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – When true, prints out whether the circuit and matrix are equal and the phase
(as a power of ω = exp(iπ/4)), if any, to which they differ.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the circuit and matrix represent the same operation (up to a global
phase), and False if they do not.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)">bool</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.exact_decomp.decompose">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.exact_decomp.</span></span><span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.matrices.SO3" title="src.pyLIQTR.gate_decomp.matrices.SO3"><span class="pre">SO3</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_objs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Sequence" title="(in Python v3.8)"><span class="pre">Sequence</span></a><span class="p"><span class="pre">[</span></span><span class="pre">A</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.List" title="(in Python v3.8)"><span class="pre">List</span></a><span class="p"><span class="pre">[</span></span><span class="pre">A</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/exact_decomp.html#decompose"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.exact_decomp.decompose" title="Link to this definition"></a></dt>
<dd><p>Decompose a matrix into its MA normal form</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.exact_decomp.exact_decomp">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.exact_decomp.</span></span><span class="sig-name descname"><span class="pre">exact_decomp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_objs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Sequence" title="(in Python v3.8)"><span class="pre">Sequence</span></a><span class="p"><span class="pre">[</span></span><span class="pre">A</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">circuit_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Tuple" title="(in Python v3.8)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.List" title="(in Python v3.8)"><span class="pre">List</span></a><span class="p"><span class="pre">[</span></span><span class="pre">A</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/exact_decomp.html#exact_decomp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.exact_decomp.exact_decomp" title="Link to this definition"></a></dt>
<dd><p>Decompose a matrix</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">1</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="p">([[</span><span class="n">u</span><span class="p">,</span> <span class="o">-</span><span class="n">t</span><span class="o">.</span><span class="n">conj</span><span class="p">()],</span>
<span class="go">                        [t,  u.conj()]])</span>
</pre></div>
</div>
<p>exactly into clifford+T gates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (<a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><em>Z_OMEGA</em></a>) – upper left matrix entry</p></li>
<li><p><strong>t</strong> (<a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><em>Z_OMEGA</em></a>) – lower left matrix entry</p></li>
<li><p><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – exponent on the 1/sqrt(2) scaling factor</p></li>
<li><p><strong>return_objs</strong> (<em>Sequence</em><em>[</em><em>A</em><em>]</em>) – A list containing the representation of the gates you would like to return.
They need to be in the following order:
[S gate, S dagger gate, H gate, X gate, Y gate, Z dagger gate, T gate].
For example, if you want to return qasm strings, this would be
&gt;&gt;&gt; [“s q0n”, “s q0ns q0ns q0”, …]
whereas if you wanted cirq gates,
&gt;&gt;&gt; [cirq.S, cirq.S**-1, …]</p></li>
<li><p><strong>circuit_order</strong> (<a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – Whether or not to arrange the gates in circuit order (the first gate applied
to the qubit is first) or “matrix order” (the first gate applied to the qubit
is last)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple consisting of a list of gates (of same type as the return_objs argument), and
and the number of T gates in the circuit.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Tuple[List[A], <a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)">int</a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.exact_decomp.exact_decomp_compressed">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.exact_decomp.</span></span><span class="sig-name descname"><span class="pre">exact_decomp_compressed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_objs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Sequence" title="(in Python v3.8)"><span class="pre">Sequence</span></a><span class="p"><span class="pre">[</span></span><span class="pre">A</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Tuple" title="(in Python v3.8)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)"><span class="pre">bool</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">A</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/exact_decomp.html#exact_decomp_compressed"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.exact_decomp.exact_decomp_compressed" title="Link to this definition"></a></dt>
<dd><p>Decompose a matrix
&gt;&gt;&gt; ((1/sqrt(2)**k) * ([[u, -t.conj()],</p>
<blockquote>
<div><p>[t,  u.conj()]])</p>
</div></blockquote>
<p>exactly into clifford+T gates.</p>
<p>Every Clifford+T operator U can be represented in MA normal form (arXiv:0806.3834):</p>
<p>U = B_n B_{n-1} B_{n-2} … B_1 C_0</p>
<p>where B_k ∈ {HT, SHT} for k ≠ n,  B_n ∈ {T, HT, SHT}, and C_0 is a clifford
operator. This function returns a “compressed” representation of the MA normal
form of a given Clifford+T operator. The compressed representation is a tuple of
four elements:</p>
<ol class="arabic simple">
<li><p>A bool indicating whether or not B_n = T</p></li>
</ol>
<p>2. An integer who’s binary representation corresponds to B_n … B_1 (if 1 is false)
or B_{n-1} … B_1 if (1 is true). We represent HT by 0 and SHT by 1.
3. The length of the sequence.
4. The clifford operator at the end of the sequence.</p>
<p>Example 1:
(T)(HT)(HT)(SHT)(SHT)(HT)(X)
has a binary representation 00110, so this becomes the tuple
(True, 6, 5, X)</p>
<p>Example 2:
(SHT)(SHT)(HT)(HT)(SHT)(S)
has binary representation 11001, so this becomes the tuple
(False, 25, 5, S)</p>
<p>Note that the binary representation is in “Matrix order” - this means that when we
want to convert the integer to a sequence of gates, we read the binary
representation “backwards” starting from the LSB.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.exact_decomp.exact_decomp_compressed_m">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.exact_decomp.</span></span><span class="sig-name descname"><span class="pre">exact_decomp_compressed_m</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA" title="src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA"><span class="pre">MAT_D_OMEGA</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_objs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Sequence" title="(in Python v3.8)"><span class="pre">Sequence</span></a><span class="p"><span class="pre">[</span></span><span class="pre">A</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Tuple" title="(in Python v3.8)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)"><span class="pre">bool</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.List" title="(in Python v3.8)"><span class="pre">List</span></a><span class="p"><span class="pre">[</span></span><span class="pre">A</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/exact_decomp.html#exact_decomp_compressed_m"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.exact_decomp.exact_decomp_compressed_m" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.exact_decomp.exact_decomp_to_matrix_string">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.exact_decomp.</span></span><span class="sig-name descname"><span class="pre">exact_decomp_to_matrix_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Tuple" title="(in Python v3.8)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3.8/library/stdtypes.html#str" title="(in Python v3.8)"><span class="pre">str</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/exact_decomp.html#exact_decomp_to_matrix_string"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.exact_decomp.exact_decomp_to_matrix_string" title="Link to this definition"></a></dt>
<dd><p>Return the gate decomposition as a string in matrix order</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.exact_decomp.exact_decomp_to_qasm">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.exact_decomp.</span></span><span class="sig-name descname"><span class="pre">exact_decomp_to_qasm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">conditional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Tuple" title="(in Python v3.8)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3.8/library/stdtypes.html#str" title="(in Python v3.8)"><span class="pre">str</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/exact_decomp.html#exact_decomp_to_qasm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.exact_decomp.exact_decomp_to_qasm" title="Link to this definition"></a></dt>
<dd><p>Return the decomposition as a list of qasm instructions</p>
<p>If conditional == True, add ‘if (r1 == 1)’ to each instruction (used in fallback
approximation)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.exact_decomp.get_equiv_class">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.exact_decomp.</span></span><span class="sig-name descname"><span class="pre">get_equiv_class</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://numpy.org/doc/1.23/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v1.23)"><span class="pre">dtype</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Any" title="(in Python v3.8)"><span class="pre">Any</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://numpy.org/doc/1.23/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v1.23)"><span class="pre">dtype</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Any" title="(in Python v3.8)"><span class="pre">Any</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)"><span class="pre">bool</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#float" title="(in Python v3.8)"><span class="pre">float</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#complex" title="(in Python v3.8)"><span class="pre">complex</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/stdtypes.html#str" title="(in Python v3.8)"><span class="pre">str</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/stdtypes.html#bytes" title="(in Python v3.8)"><span class="pre">bytes</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)"><span class="pre">bool</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#float" title="(in Python v3.8)"><span class="pre">float</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#complex" title="(in Python v3.8)"><span class="pre">complex</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/stdtypes.html#str" title="(in Python v3.8)"><span class="pre">str</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/stdtypes.html#bytes" title="(in Python v3.8)"><span class="pre">bytes</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/exact_decomp.html#get_equiv_class"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.exact_decomp.get_equiv_class" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.exact_decomp.get_syllables">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.exact_decomp.</span></span><span class="sig-name descname"><span class="pre">get_syllables</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_objs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Sequence" title="(in Python v3.8)"><span class="pre">Sequence</span></a><span class="p"><span class="pre">[</span></span><span class="pre">A</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Tuple" title="(in Python v3.8)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.List" title="(in Python v3.8)"><span class="pre">List</span></a><span class="p"><span class="pre">[</span></span><span class="pre">A</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/exact_decomp.html#get_syllables"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.exact_decomp.get_syllables" title="Link to this definition"></a></dt>
<dd><p>Return the ‘syllables’ of MA normal form using the return objs</p>
<p>MA normal form puts the gates into sequnces A1A2…AnC, where each Ai
is one of the ‘syllables’ HT, SHT, or T, and then C is a clifford. This
function returns a tuple of the syllables using the return_objs.</p>
</dd></dl>

</section>
<section id="module-src.pyLIQTR.gate_decomp.gate_approximation">
<span id="src-pyliqtr-gate-decomp-gate-approximation-module"></span><h2>src.pyLIQTR.gate_decomp.gate_approximation module<a class="headerlink" href="#module-src.pyLIQTR.gate_decomp.gate_approximation" title="Link to this heading"></a></h2>
<p>Copyright (c) 2024 Massachusetts Institute of Technology
SPDX-License-Identifier: BSD-2-Clause</p>
<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.gate_approximation.approxRz_direct">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.gate_approximation.</span></span><span class="sig-name descname"><span class="pre">approxRz_direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Tuple" title="(in Python v3.8)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/gate_approximation.html#approxRz_direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.gate_approximation.approxRz_direct" title="Link to this definition"></a></dt>
<dd><p>Approximate Rz(theta) as a unitary with entries from the ring D[ω]
where D[ω] = {1/√2^k(aω^3 + bω^2 + cω + d) | k ∈ N, a, b, c, d ∈ Z}</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.gate_approximation.approxRz_fallback">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.gate_approximation.</span></span><span class="sig-name descname"><span class="pre">approxRz_fallback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Tuple" title="(in Python v3.8)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/gate_approximation.html#approxRz_fallback"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.gate_approximation.approxRz_fallback" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.gate_approximation.approximate_rz_direct">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.gate_approximation.</span></span><span class="sig-name descname"><span class="pre">approximate_rz_direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">numerator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">denominator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_qasm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/stdtypes.html#str" title="(in Python v3.8)"><span class="pre">str</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/gate_approximation.html#approximate_rz_direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.gate_approximation.approximate_rz_direct" title="Link to this definition"></a></dt>
<dd><p>Approximate a Z-rotation of the angle numerator*pi/denominator to the precision
10^{-prec} in the operator norm.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.gate_approximation.approximate_rz_fallback">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.gate_approximation.</span></span><span class="sig-name descname"><span class="pre">approximate_rz_fallback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">numerator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">denominator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">mpfr('0.999')</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_qasm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Tuple" title="(in Python v3.8)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3.8/library/stdtypes.html#str" title="(in Python v3.8)"><span class="pre">str</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/stdtypes.html#str" title="(in Python v3.8)"><span class="pre">str</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Tuple" title="(in Python v3.8)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3.8/library/stdtypes.html#str" title="(in Python v3.8)"><span class="pre">str</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/gate_approximation.html#approximate_rz_fallback"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.gate_approximation.approximate_rz_fallback" title="Link to this definition"></a></dt>
<dd><p>Approximate a Z-rotation of the angle numerator*pi/denominator to the precision
10^{-prec} in the diamond norm using the fallback protocol.</p>
<p>The return type depends on the parameter use_qasm. If set to False, this function
returns a tuple containing the primary gate sequence, its T count, the secondary
gate sequence, and its T count. If set to True, the function returns a tuple with
the fallback circuit as a qasm circuit, the primary T count, and the secondary T
count. In the qasm circuit, q0 is the qubit upon which we are performing the
rotation, and q1 is the ancilla qubit initialized in the zero state.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.gate_approximation.check_common_cases">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.gate_approximation.</span></span><span class="sig-name descname"><span class="pre">check_common_cases</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">numerator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">denominator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_qasm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)"><span class="pre">bool</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/stdtypes.html#str" title="(in Python v3.8)"><span class="pre">str</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/constants.html#None" title="(in Python v3.8)"><span class="pre">None</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/gate_approximation.html#check_common_cases"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.gate_approximation.check_common_cases" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.gate_approximation.corrections">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.gate_approximation.</span></span><span class="sig-name descname"><span class="pre">corrections</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/gate_approximation.html#corrections"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.gate_approximation.corrections" title="Link to this definition"></a></dt>
<dd><p>Find the multiple of pi/2 that when added to theta, results in
theta+correction ∈ [-pi/4, pi/4]</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.gate_approximation.get_ring_elts_direct">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.gate_approximation.</span></span><span class="sig-name descname"><span class="pre">get_ring_elts_direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init_theta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#float" title="(in Python v3.8)"><span class="pre">float</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prec</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/constants.html#None" title="(in Python v3.8)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Tuple" title="(in Python v3.8)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/gate_approximation.html#get_ring_elts_direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.gate_approximation.get_ring_elts_direct" title="Link to this definition"></a></dt>
<dd><p>Given an angle θ, find elements u, t ∈ Z[ω], and an integer k such that the matrix
(1/√2^k) | u -t^* |</p>
<blockquote>
<div><div class="line-block">
<div class="line">t  u^* |</div>
</div>
</div></blockquote>
<p>approximates a Z-rotation over the angle theta, i.e. the operator
| exp(-iθ/2)  0 |
|   0 exp(iθ/2) |</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.gate_approximation.get_ring_elts_fallback">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.gate_approximation.</span></span><span class="sig-name descname"><span class="pre">get_ring_elts_fallback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init_theta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#float" title="(in Python v3.8)"><span class="pre">float</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prec</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Tuple" title="(in Python v3.8)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/gate_approximation.html#get_ring_elts_fallback"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.gate_approximation.get_ring_elts_fallback" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.gate_approximation.is_reducible">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.gate_approximation.</span></span><span class="sig-name descname"><span class="pre">is_reducible</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)"><span class="pre">bool</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/gate_approximation.html#is_reducible"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.gate_approximation.is_reducible" title="Link to this definition"></a></dt>
<dd><p>Given a value u ∈ Z[ω], determine that supposing if we had some
w = (1/√2^k)u ∈ D[ω], we could re-write w as w = (1/√2^(k-1))u’ ∈ D[ω]
for some u’ ∈ Z[ω].</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.gate_approximation.reduce">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.gate_approximation.</span></span><span class="sig-name descname"><span class="pre">reduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/gate_approximation.html#reduce"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.gate_approximation.reduce" title="Link to this definition"></a></dt>
<dd><p>Given a u ∈ Z[ω] such that is_reducible(u) is True, return u’ such that
(1/√2^k)u = (1/√2^(k-1))u’.</p>
</dd></dl>

</section>
<section id="module-src.pyLIQTR.gate_decomp.grid_operator">
<span id="src-pyliqtr-gate-decomp-grid-operator-module"></span><h2>src.pyLIQTR.gate_decomp.grid_operator module<a class="headerlink" href="#module-src.pyLIQTR.gate_decomp.grid_operator" title="Link to this heading"></a></h2>
<p>Copyright (c) 2024 Massachusetts Institute of Technology
SPDX-License-Identifier: BSD-2-Clause</p>
<dl class="py class">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.grid_operator.GridOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.grid_operator.</span></span><span class="sig-name descname"><span class="pre">GridOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">ap</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">bp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">cp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/grid_operator.html#GridOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.grid_operator.GridOperator" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3.8/library/functions.html#object" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A class defining linear operators G such that for all u ∈ Z[ω], Gu ∈ Z[ω].</p>
<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.grid_operator.GridOperator.A">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">A</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/grid_operator.html#GridOperator.A"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.grid_operator.GridOperator.A" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.grid_operator.GridOperator.APowN">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">APowN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/grid_operator.html#GridOperator.APowN"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.grid_operator.GridOperator.APowN" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.grid_operator.GridOperator.B">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">B</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/grid_operator.html#GridOperator.B"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.grid_operator.GridOperator.B" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.grid_operator.GridOperator.BPowN">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">BPowN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/grid_operator.html#GridOperator.BPowN"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.grid_operator.GridOperator.BPowN" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.grid_operator.GridOperator.I">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">I</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/grid_operator.html#GridOperator.I"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.grid_operator.GridOperator.I" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.grid_operator.GridOperator.K">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">K</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/grid_operator.html#GridOperator.K"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.grid_operator.GridOperator.K" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.grid_operator.GridOperator.R">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">R</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/grid_operator.html#GridOperator.R"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.grid_operator.GridOperator.R" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.grid_operator.GridOperator.X">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">X</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/grid_operator.html#GridOperator.X"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.grid_operator.GridOperator.X" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.grid_operator.GridOperator.Z">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Z</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/grid_operator.html#GridOperator.Z"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.grid_operator.GridOperator.Z" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.grid_operator.GridOperator.conj2">
<span class="sig-name descname"><span class="pre">conj2</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/grid_operator.html#GridOperator.conj2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.grid_operator.GridOperator.conj2" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.grid_operator.GridOperator.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/grid_operator.html#GridOperator.inverse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.grid_operator.GridOperator.inverse" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.grid_operator.GridOperator.mult_x_y_pt">
<span class="sig-name descname"><span class="pre">mult_x_y_pt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Tuple" title="(in Python v3.8)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><span class="pre">mpfr</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">mpfr</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/grid_operator.html#GridOperator.mult_x_y_pt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.grid_operator.GridOperator.mult_x_y_pt" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.grid_operator.GridOperator.multiply_z_omega">
<span class="sig-name descname"><span class="pre">multiply_z_omega</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/grid_operator.html#GridOperator.multiply_z_omega"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.grid_operator.GridOperator.multiply_z_omega" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.grid_operator.GridOperator.transpose">
<span class="sig-name descname"><span class="pre">transpose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/grid_operator.html#GridOperator.transpose"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.grid_operator.GridOperator.transpose" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-src.pyLIQTR.gate_decomp.matrices">
<span id="src-pyliqtr-gate-decomp-matrices-module"></span><h2>src.pyLIQTR.gate_decomp.matrices module<a class="headerlink" href="#module-src.pyLIQTR.gate_decomp.matrices" title="Link to this heading"></a></h2>
<p>Copyright (c) 2024 Massachusetts Institute of Technology
SPDX-License-Identifier: BSD-2-Clause</p>
<dl class="py class">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.matrices.</span></span><span class="sig-name descname"><span class="pre">MAT_D_OMEGA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a00</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a11</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/matrices.html#MAT_D_OMEGA"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3.8/library/functions.html#object" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A class of 2x2 matrices over the ring D[ω]</p>
<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.H">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">H</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/matrices.html#MAT_D_OMEGA.H"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.H" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.I">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">I</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/matrices.html#MAT_D_OMEGA.I"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.I" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.S">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">S</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/matrices.html#MAT_D_OMEGA.S"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.S" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.Sd">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Sd</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/matrices.html#MAT_D_OMEGA.Sd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.Sd" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.T">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">T</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/matrices.html#MAT_D_OMEGA.T"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.T" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.Td">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Td</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/matrices.html#MAT_D_OMEGA.Td"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.Td" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.X">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">X</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/matrices.html#MAT_D_OMEGA.X"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.X" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.Y">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Y</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/matrices.html#MAT_D_OMEGA.Y"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.Y" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.Z">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Z</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/matrices.html#MAT_D_OMEGA.Z"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.Z" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/matrices.html#MAT_D_OMEGA.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.adjoint" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.convert_to_so3">
<span class="sig-name descname"><span class="pre">convert_to_so3</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/matrices.html#MAT_D_OMEGA.convert_to_so3"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.convert_to_so3" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.elements">
<span class="sig-name descname"><span class="pre">elements</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/matrices.html#MAT_D_OMEGA.elements"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.elements" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.mult_pow_2">
<span class="sig-name descname"><span class="pre">mult_pow_2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/matrices.html#MAT_D_OMEGA.mult_pow_2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.mult_pow_2" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.reduce_by_sqrt2">
<span class="sig-name descname"><span class="pre">reduce_by_sqrt2</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/matrices.html#MAT_D_OMEGA.reduce_by_sqrt2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.reduce_by_sqrt2" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.to_array">
<span class="sig-name descname"><span class="pre">to_array</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/matrices.html#MAT_D_OMEGA.to_array"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.matrices.MAT_D_OMEGA.to_array" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.matrices.SO3">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.matrices.</span></span><span class="sig-name descname"><span class="pre">SO3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u00</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u02</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u11</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u21</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u22</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/matrices.html#SO3"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.matrices.SO3" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3.8/library/functions.html#object" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A class representing the Bloch sphere representation of a unitary operator.</p>
<p>Given an operator U ∈ U(2), define its Bloch sphere representation B ∈ SO(3) as
the operator such that if
U(xX + yY + zZ)U^† = x’X + y’Y + z’Z, then
B(x y z)^T = (x’ y’ z’)^T</p>
<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.matrices.SO3.elements">
<span class="sig-name descname"><span class="pre">elements</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.List" title="(in Python v3.8)"><span class="pre">List</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_SQRT2" title="src.pyLIQTR.gate_decomp.rings.Z_SQRT2"><span class="pre">Z_SQRT2</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/matrices.html#SO3.elements"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.matrices.SO3.elements" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.matrices.SO3.get_parity">
<span class="sig-name descname"><span class="pre">get_parity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/matrices.html#SO3.get_parity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.matrices.SO3.get_parity" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.matrices.SO3.reduce">
<span class="sig-name descname"><span class="pre">reduce</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/matrices.html#SO3.reduce"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.matrices.SO3.reduce" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.matrices.SO3.reduce_by_1">
<span class="sig-name descname"><span class="pre">reduce_by_1</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)"><span class="pre">bool</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/matrices.html#SO3.reduce_by_1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.matrices.SO3.reduce_by_1" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.matrices.SO3.reduce_by_2">
<span class="sig-name descname"><span class="pre">reduce_by_2</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)"><span class="pre">bool</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/matrices.html#SO3.reduce_by_2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.matrices.SO3.reduce_by_2" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.matrices.convert_to_zsqrti">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.matrices.</span></span><span class="sig-name descname"><span class="pre">convert_to_zsqrti</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/matrices.html#convert_to_zsqrti"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.matrices.convert_to_zsqrti" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.matrices.convert_to_zsqrti_increase_k">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.matrices.</span></span><span class="sig-name descname"><span class="pre">convert_to_zsqrti_increase_k</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/matrices.html#convert_to_zsqrti_increase_k"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.matrices.convert_to_zsqrti_increase_k" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.matrices.is_odd">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.matrices.</span></span><span class="sig-name descname"><span class="pre">is_odd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/matrices.html#is_odd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.matrices.is_odd" title="Link to this definition"></a></dt>
<dd></dd></dl>

</section>
<section id="module-src.pyLIQTR.gate_decomp.point_enumeration">
<span id="src-pyliqtr-gate-decomp-point-enumeration-module"></span><h2>src.pyLIQTR.gate_decomp.point_enumeration module<a class="headerlink" href="#module-src.pyLIQTR.gate_decomp.point_enumeration" title="Link to this heading"></a></h2>
<p>DISTRIBUTION STATEMENT A. Approved for public release. Distribution is unlimited.</p>
<p>This material is based upon work supported by the Under Secretary of Defense for
Research and Engineering under Air Force Contract No. FA8702-15-D-0001. Any opinions,
findings, conclusions or recommendations expressed in this material are those of the
author(s) and do not necessarily reflect the views of the Under Secretary of Defense
for Research and Engineering.</p>
<p>© 2022 Massachusetts Institute of Technology.</p>
<p>The software/firmware is provided to you on an As-Is basis</p>
<p>Delivered to the U.S. Government with Unlimited Rights, as defined in DFARS Part
252.227-7013 or 7014 (Feb 2014). Notwithstanding any copyright notice, U.S. Government
rights in this work are defined by DFARS 252.227-7013 or DFARS 252.227-7014 as detailed
above. Use of this work other than as specifically authorized by the U.S. Government
may violate any copyrights that exist in this work.</p>
<p>Functions for enumerating points of the ring D[ω] in various subregions of the unit
disk. Uses methods described in [1].
[1] - arXiv:1403.2975</p>
<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.point_enumeration.apply_grid_operator">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.point_enumeration.</span></span><span class="sig-name descname"><span class="pre">apply_grid_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid_op</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.grid_operator.GridOperator" title="src.pyLIQTR.gate_decomp.grid_operator.GridOperator"><span class="pre">GridOperator</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">ellipse1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="src.pyLIQTR.gate_decomp.ellipse.Ellipse"><span class="pre">Ellipse</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">ellipse2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="src.pyLIQTR.gate_decomp.ellipse.Ellipse"><span class="pre">Ellipse</span></a></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/point_enumeration.html#apply_grid_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.point_enumeration.apply_grid_operator" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.point_enumeration.apply_op_to_ellipse">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.point_enumeration.</span></span><span class="sig-name descname"><span class="pre">apply_op_to_ellipse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid_op</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.grid_operator.GridOperator" title="src.pyLIQTR.gate_decomp.grid_operator.GridOperator"><span class="pre">GridOperator</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">ellipse</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="src.pyLIQTR.gate_decomp.ellipse.Ellipse"><span class="pre">Ellipse</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="src.pyLIQTR.gate_decomp.ellipse.Ellipse"><span class="pre">Ellipse</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/point_enumeration.html#apply_op_to_ellipse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.point_enumeration.apply_op_to_ellipse" title="Link to this definition"></a></dt>
<dd><p>Given a grid op G and ellipse E, performs the matrix multiplication
(G^T)EG</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.point_enumeration.apply_shift_operator">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.point_enumeration.</span></span><span class="sig-name descname"><span class="pre">apply_shift_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_op</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.grid_operator.GridOperator" title="src.pyLIQTR.gate_decomp.grid_operator.GridOperator"><span class="pre">GridOperator</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.grid_operator.GridOperator" title="src.pyLIQTR.gate_decomp.grid_operator.GridOperator"><span class="pre">GridOperator</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/point_enumeration.html#apply_shift_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.point_enumeration.apply_shift_operator" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.point_enumeration.candidate_generator_direct">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.point_enumeration.</span></span><span class="sig-name descname"><span class="pre">candidate_generator_direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Iterable" title="(in Python v3.8)"><span class="pre">Iterable</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Tuple" title="(in Python v3.8)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/point_enumeration.html#candidate_generator_direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.point_enumeration.candidate_generator_direct" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.point_enumeration.candidate_generator_fallback">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.point_enumeration.</span></span><span class="sig-name descname"><span class="pre">candidate_generator_fallback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Iterable" title="(in Python v3.8)"><span class="pre">Iterable</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Tuple" title="(in Python v3.8)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/point_enumeration.html#candidate_generator_fallback"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.point_enumeration.candidate_generator_fallback" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.point_enumeration.determine_shift_operator">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.point_enumeration.</span></span><span class="sig-name descname"><span class="pre">determine_shift_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ellipse1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="src.pyLIQTR.gate_decomp.ellipse.Ellipse"><span class="pre">Ellipse</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">ellipse2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="src.pyLIQTR.gate_decomp.ellipse.Ellipse"><span class="pre">Ellipse</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Tuple" title="(in Python v3.8)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="src.pyLIQTR.gate_decomp.ellipse.Ellipse"><span class="pre">Ellipse</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="src.pyLIQTR.gate_decomp.ellipse.Ellipse"><span class="pre">Ellipse</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/point_enumeration.html#determine_shift_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.point_enumeration.determine_shift_operator" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.point_enumeration.find_bounding_ellipse_direct">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.point_enumeration.</span></span><span class="sig-name descname"><span class="pre">find_bounding_ellipse_direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="src.pyLIQTR.gate_decomp.ellipse.Ellipse"><span class="pre">Ellipse</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/point_enumeration.html#find_bounding_ellipse_direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.point_enumeration.find_bounding_ellipse_direct" title="Link to this definition"></a></dt>
<dd><p>Given an epsilon and a phi, find x0, y0, a, b, and d such that the ellipse defined by
a(x-x0)^2 + 2b(x-x0)(y-y0) + d(y-y0)^2 = (ab)^2
is the smallest ellipse that bounds the region
{u | u•z &gt;= 1 - ε^2 / 2}
where z = exp(iφ)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.point_enumeration.find_bounding_ellipse_fallback">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.point_enumeration.</span></span><span class="sig-name descname"><span class="pre">find_bounding_ellipse_fallback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="src.pyLIQTR.gate_decomp.ellipse.Ellipse"><span class="pre">Ellipse</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/point_enumeration.html#find_bounding_ellipse_fallback"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.point_enumeration.find_bounding_ellipse_fallback" title="Link to this definition"></a></dt>
<dd><p>Given and epsilon, phi, r, and k, return the (approximately) smallest ellipse that
bounds the region
C = {u | <a href="#id1"><span class="problematic" id="id2">|u|</span></a> &gt;= r and Arg(u)∈[θ - δ, θ + δ]}
for δ = arcsin(eps/2)</p>
<p>The ellipse has the form
a(x-x0)^2 + 2b(x-x0)(y-y0) + d(y-y0)^2 = 1</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.point_enumeration.find_ellipse_bounding_box">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.point_enumeration.</span></span><span class="sig-name descname"><span class="pre">find_ellipse_bounding_box</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ellipse</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="src.pyLIQTR.gate_decomp.ellipse.Ellipse"><span class="pre">Ellipse</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Tuple" title="(in Python v3.8)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><span class="pre">mpfr</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">mpfr</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">mpfr</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">mpfr</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/point_enumeration.html#find_ellipse_bounding_box"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.point_enumeration.find_ellipse_bounding_box" title="Link to this definition"></a></dt>
<dd><p>Given the matrix elements of an ellipse defined as a 2x2 positive definite matrix:</p>
<div class="line-block">
<div class="line">a  b |</div>
</div>
<div class="line-block">
<div class="line">b  d |</div>
</div>
<p>return its bounding box in the form [[x0, x1], [y0, y1]]</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.point_enumeration.find_grid_operator">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.point_enumeration.</span></span><span class="sig-name descname"><span class="pre">find_grid_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ellipse1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="src.pyLIQTR.gate_decomp.ellipse.Ellipse"><span class="pre">Ellipse</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">ellipse2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="src.pyLIQTR.gate_decomp.ellipse.Ellipse"><span class="pre">Ellipse</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.grid_operator.GridOperator" title="src.pyLIQTR.gate_decomp.grid_operator.GridOperator"><span class="pre">GridOperator</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/point_enumeration.html#find_grid_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.point_enumeration.find_grid_operator" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.point_enumeration.find_k">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.point_enumeration.</span></span><span class="sig-name descname"><span class="pre">find_k</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/point_enumeration.html#find_k"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.point_enumeration.find_k" title="Link to this definition"></a></dt>
<dd><p>Given some value δ &gt;= 1, find the smallest integer k such that δ * (λ^-1)^k &lt; 1,
where λ = 1 + √2</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.point_enumeration.find_u_candidates_direct">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.point_enumeration.</span></span><span class="sig-name descname"><span class="pre">find_u_candidates_direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.List" title="(in Python v3.8)"><span class="pre">List</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Tuple" title="(in Python v3.8)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/point_enumeration.html#find_u_candidates_direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.point_enumeration.find_u_candidates_direct" title="Link to this definition"></a></dt>
<dd><p>Find all of the u candidates for the lowest k at which a candidate exists</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.point_enumeration.get_num_pot_sols">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.point_enumeration.</span></span><span class="sig-name descname"><span class="pre">get_num_pot_sols</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/point_enumeration.html#get_num_pot_sols"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.point_enumeration.get_num_pot_sols" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.point_enumeration.get_num_pot_sols_scaled">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.point_enumeration.</span></span><span class="sig-name descname"><span class="pre">get_num_pot_sols_scaled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/point_enumeration.html#get_num_pot_sols_scaled"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.point_enumeration.get_num_pot_sols_scaled" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.point_enumeration.reduce_skew">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.point_enumeration.</span></span><span class="sig-name descname"><span class="pre">reduce_skew</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ellipse1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="src.pyLIQTR.gate_decomp.ellipse.Ellipse"><span class="pre">Ellipse</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">ellipse2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="src.pyLIQTR.gate_decomp.ellipse.Ellipse"><span class="pre">Ellipse</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Tuple" title="(in Python v3.8)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#src.pyLIQTR.gate_decomp.grid_operator.GridOperator" title="src.pyLIQTR.gate_decomp.grid_operator.GridOperator"><span class="pre">GridOperator</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="src.pyLIQTR.gate_decomp.ellipse.Ellipse"><span class="pre">Ellipse</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="src.pyLIQTR.gate_decomp.ellipse.Ellipse"><span class="pre">Ellipse</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/point_enumeration.html#reduce_skew"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.point_enumeration.reduce_skew" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.point_enumeration.scaled_one_dim_grid_problem">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.point_enumeration.</span></span><span class="sig-name descname"><span class="pre">scaled_one_dim_grid_problem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Iterable" title="(in Python v3.8)"><span class="pre">Iterable</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_SQRT2" title="src.pyLIQTR.gate_decomp.rings.Z_SQRT2"><span class="pre">Z_SQRT2</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/point_enumeration.html#scaled_one_dim_grid_problem"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.point_enumeration.scaled_one_dim_grid_problem" title="Link to this definition"></a></dt>
<dd><p>Enumerate solutions to the scaled one dimensional grid problem for intervals [x0, x1],
[y0, y1], i.e solve the one dimensional grid problem in the specific case that
-1 + √2 &lt;= x1 - x0 &lt; 1.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.point_enumeration.solve_one_dim_grid_problem">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.point_enumeration.</span></span><span class="sig-name descname"><span class="pre">solve_one_dim_grid_problem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Iterable" title="(in Python v3.8)"><span class="pre">Iterable</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_SQRT2" title="src.pyLIQTR.gate_decomp.rings.Z_SQRT2"><span class="pre">Z_SQRT2</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/point_enumeration.html#solve_one_dim_grid_problem"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.point_enumeration.solve_one_dim_grid_problem" title="Link to this definition"></a></dt>
<dd><p>Enumerate solutions to the one dimensional grid problem given intervals [x0, x1] and
[y0, y1].</p>
<p>Given two real intervals [x0, x1] and [y0, y1] such that
(x1 - x0)*(y1 - y0) &gt;= (1 + √2)^2, enumerate all numbers of the form a + b√2 such
that a + b√2 ∈ [x0, x1] and a - b√2 ∈ [y0, y1].</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.point_enumeration.solve_two_dim_grid_problem_ellipse">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.point_enumeration.</span></span><span class="sig-name descname"><span class="pre">solve_two_dim_grid_problem_ellipse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ellipse1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="src.pyLIQTR.gate_decomp.ellipse.Ellipse"><span class="pre">Ellipse</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">ellipse2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="src.pyLIQTR.gate_decomp.ellipse.Ellipse"><span class="pre">Ellipse</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/constants.html#None" title="(in Python v3.8)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intercept</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/constants.html#None" title="(in Python v3.8)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">valid_region_above</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)"><span class="pre">bool</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/constants.html#None" title="(in Python v3.8)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">valid_region_right</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)"><span class="pre">bool</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/constants.html#None" title="(in Python v3.8)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Iterable" title="(in Python v3.8)"><span class="pre">Iterable</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/point_enumeration.html#solve_two_dim_grid_problem_ellipse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.point_enumeration.solve_two_dim_grid_problem_ellipse" title="Link to this definition"></a></dt>
<dd><p>Given the matrix elements of two ellipses A and B centered at (x1, y1) and
(x2, y2) defined as a 2x2 positive definite matrices:]</p>
<div class="line-block">
<div class="line">a  b |</div>
</div>
<div class="line-block">
<div class="line">b  d |</div>
</div>
<p>return the list of elements u ∈ Z[ω] such that u ∈ A and u.conj2 ∈ B (where conj2 is
sqrt(2) conjugation)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.point_enumeration.solve_two_dim_grid_problem_upright_rectangles">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.point_enumeration.</span></span><span class="sig-name descname"><span class="pre">solve_two_dim_grid_problem_upright_rectangles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Ax0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ax1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ay0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ay1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Bx0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Bx1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">By0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">By1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ellipse1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="src.pyLIQTR.gate_decomp.ellipse.Ellipse"><span class="pre">Ellipse</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/constants.html#None" title="(in Python v3.8)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ellipse2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.ellipse.Ellipse" title="src.pyLIQTR.gate_decomp.ellipse.Ellipse"><span class="pre">Ellipse</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3.8/library/constants.html#None" title="(in Python v3.8)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Iterable" title="(in Python v3.8)"><span class="pre">Iterable</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/point_enumeration.html#solve_two_dim_grid_problem_upright_rectangles"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.point_enumeration.solve_two_dim_grid_problem_upright_rectangles" title="Link to this definition"></a></dt>
<dd><p>Given two subregions A and B, of R^2, of the form A,B = [x0, x1] x [y0, y1], find
all u ∈ Z[ω] such that u ∈ A and u.conj2() ∈ B (where conj2 is sqrt(2) conjugation)</p>
</dd></dl>

</section>
<section id="module-src.pyLIQTR.gate_decomp.rings">
<span id="src-pyliqtr-gate-decomp-rings-module"></span><h2>src.pyLIQTR.gate_decomp.rings module<a class="headerlink" href="#module-src.pyLIQTR.gate_decomp.rings" title="Link to this heading"></a></h2>
<p>Copyright (c) 2024 Massachusetts Institute of Technology
SPDX-License-Identifier: BSD-2-Clause</p>
<dl class="py class">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rings.Z_OMEGA">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.rings.</span></span><span class="sig-name descname"><span class="pre">Z_OMEGA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a4</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/rings.html#Z_OMEGA"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3.8/library/functions.html#object" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A class representing the ring
Z[ω] = {a1ω^3 + a2ω^2 + a3ω + a4 | a1, a2, a3, a4 ∈ Z}
with ω = exp(iπ/4)</p>
<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rings.Z_OMEGA.conj">
<span class="sig-name descname"><span class="pre">conj</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/rings.html#Z_OMEGA.conj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA.conj" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rings.Z_OMEGA.conj2">
<span class="sig-name descname"><span class="pre">conj2</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/rings.html#Z_OMEGA.conj2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA.conj2" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rings.Z_OMEGA.from_Z_SQRT2">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_Z_SQRT2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_SQRT2" title="src.pyLIQTR.gate_decomp.rings.Z_SQRT2"><span class="pre">Z_SQRT2</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_SQRT2" title="src.pyLIQTR.gate_decomp.rings.Z_SQRT2"><span class="pre">Z_SQRT2</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/rings.html#Z_OMEGA.from_Z_SQRT2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA.from_Z_SQRT2" title="Link to this definition"></a></dt>
<dd><p>Initialize an element of the ring Z[ω] using two elements from the ring Z[√2]
such that c = a + bi ∈ Z[ω]</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rings.Z_OMEGA.magnitude_squared">
<span class="sig-name descname"><span class="pre">magnitude_squared</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/rings.html#Z_OMEGA.magnitude_squared"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA.magnitude_squared" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rings.Z_OMEGA.mul_by_sqrt2">
<span class="sig-name descname"><span class="pre">mul_by_sqrt2</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/rings.html#Z_OMEGA.mul_by_sqrt2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA.mul_by_sqrt2" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rings.Z_OMEGA.to_zsqrt">
<span class="sig-name descname"><span class="pre">to_zsqrt</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_SQRT2" title="src.pyLIQTR.gate_decomp.rings.Z_SQRT2"><span class="pre">Z_SQRT2</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/rings.html#Z_OMEGA.to_zsqrt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA.to_zsqrt" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rings.Z_SQRT2">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.rings.</span></span><span class="sig-name descname"><span class="pre">Z_SQRT2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/rings.html#Z_SQRT2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rings.Z_SQRT2" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3.8/library/functions.html#object" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A class representing the ring
Z[√2] = {a + b√2 | a, b ∈ Z}</p>
<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rings.Z_SQRT2.conj">
<span class="sig-name descname"><span class="pre">conj</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_SQRT2" title="src.pyLIQTR.gate_decomp.rings.Z_SQRT2"><span class="pre">Z_SQRT2</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/rings.html#Z_SQRT2.conj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rings.Z_SQRT2.conj" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rings.Z_SQRT2.divide">
<span class="sig-name descname"><span class="pre">divide</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_SQRT2" title="src.pyLIQTR.gate_decomp.rings.Z_SQRT2"><span class="pre">Z_SQRT2</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_SQRT2" title="src.pyLIQTR.gate_decomp.rings.Z_SQRT2"><span class="pre">Z_SQRT2</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/rings.html#Z_SQRT2.divide"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rings.Z_SQRT2.divide" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rings.Z_SQRT2.divide_sqrt2">
<span class="sig-name descname"><span class="pre">divide_sqrt2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_SQRT2" title="src.pyLIQTR.gate_decomp.rings.Z_SQRT2"><span class="pre">Z_SQRT2</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_SQRT2" title="src.pyLIQTR.gate_decomp.rings.Z_SQRT2"><span class="pre">Z_SQRT2</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/rings.html#Z_SQRT2.divide_sqrt2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rings.Z_SQRT2.divide_sqrt2" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rings.Z_SQRT2.sqrt">
<span class="sig-name descname"><span class="pre">sqrt</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_SQRT2" title="src.pyLIQTR.gate_decomp.rings.Z_SQRT2"><span class="pre">Z_SQRT2</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/rings.html#Z_SQRT2.sqrt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rings.Z_SQRT2.sqrt" title="Link to this definition"></a></dt>
<dd><p>Compute A = a + b√2 such that A*A = self</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3.8/library/exceptions.html#ValueError" title="(in Python v3.8)"><strong>ValueError</strong></a> – If the object is not a square</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rings.Z_SQRT2.to_zomega">
<span class="sig-name descname"><span class="pre">to_zomega</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/rings.html#Z_SQRT2.to_zomega"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rings.Z_SQRT2.to_zomega" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rings.increase">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.rings.</span></span><span class="sig-name descname"><span class="pre">increase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/rings.html#increase"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rings.increase" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rings.is_reducible">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.rings.</span></span><span class="sig-name descname"><span class="pre">is_reducible</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#bool" title="(in Python v3.8)"><span class="pre">bool</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/rings.html#is_reducible"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rings.is_reducible" title="Link to this definition"></a></dt>
<dd><p>Given a value u ∈ Z[ω], determine that supposing if we had some
w = (1/√2^k)u ∈ D[ω], we could re-write w as w = (1/√2^(k-1))u’ ∈ D[ω]
for some u’ ∈ Z[ω].</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rings.reduce">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.rings.</span></span><span class="sig-name descname"><span class="pre">reduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/rings.html#reduce"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rings.reduce" title="Link to this definition"></a></dt>
<dd><p>Given a u ∈ Z[ω] such that is_reducible(u) is True, return u’ such that
(1/√2^k)u = (1/√2^(k-1))u’.</p>
</dd></dl>

</section>
<section id="module-src.pyLIQTR.gate_decomp.rotation_gates">
<span id="src-pyliqtr-gate-decomp-rotation-gates-module"></span><h2>src.pyLIQTR.gate_decomp.rotation_gates module<a class="headerlink" href="#module-src.pyLIQTR.gate_decomp.rotation_gates" title="Link to this heading"></a></h2>
<p>DISTRIBUTION STATEMENT A. Approved for public release. Distribution is unlimited.</p>
<p>This material is based upon work supported by the Under Secretary of Defense for
Research and Engineering under Air Force Contract No. FA8702-15-D-0001. Any opinions,
findings, conclusions or recommendations expressed in this material are those of the
author(s) and do not necessarily reflect the views of the Under Secretary of Defense
for Research and Engineering.</p>
<p>© 2022 Massachusetts Institute of Technology.</p>
<p>The software/firmware is provided to you on an As-Is basis</p>
<p>Delivered to the U.S. Government with Unlimited Rights, as defined in DFARS Part
252.227-7013 or 7014 (Feb 2014). Notwithstanding any copyright notice, U.S. Government
rights in this work are defined by DFARS 252.227-7013 or DFARS 252.227-7014 as detailed
above. Use of this work other than as specifically authorized by the U.S. Government
may violate any copyrights that exist in this work.</p>
<p>Custom rotation gates that calculate their Clifford+T decomposition when initialized,
and then implement that when cirq.decompose() is called.</p>
<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rotation_gates.check_common_angles">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.rotation_gates.</span></span><span class="sig-name descname"><span class="pre">check_common_angles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">angle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpfr</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/constants.html#None" title="(in Python v3.8)"><span class="pre">None</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Gate</span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/rotation_gates.html#check_common_angles"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rotation_gates.check_common_angles" title="Link to this definition"></a></dt>
<dd><p>Note that if θ2 is our target angle and θ1 is one of the rotations we can perform exactly (i.e a multiple of π/8), and <a href="#id3"><span class="problematic" id="id4">|θ1 - θ2|</span></a>/2 is less than our desired error we can just use that gate, as err = sqrt(2 - 2Re(u*z)), so if we let u=exp(i*θ1/2) and z=exp(i*θ2/2), then</p>
<dl class="simple">
<dt>err = sqrt(2-2Re(u*z))</dt><dd><p>= sqrt(2-2cos((θ1-θ2)/2))
= 2*sin((θ1-θ2)/4)</p>
</dd>
</dl>
<p>NOTE: Assumes incoming rotation angles are in the range [-π, π]</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rotation_gates.decomp_mixin">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.rotation_gates.</span></span><span class="sig-name descname"><span class="pre">decomp_mixin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rads</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_random_decomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/rotation_gates.html#decomp_mixin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rotation_gates.decomp_mixin" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Gate</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rotation_gates.decomp_mixin.get_Clifford_count">
<span class="sig-name descname"><span class="pre">get_Clifford_count</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/rotation_gates.html#decomp_mixin.get_Clifford_count"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rotation_gates.decomp_mixin.get_Clifford_count" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rotation_gates.decomp_mixin.get_T_count">
<span class="sig-name descname"><span class="pre">get_T_count</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/rotation_gates.html#decomp_mixin.get_T_count"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rotation_gates.decomp_mixin.get_T_count" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rotation_gates.decomp_mixin.get_resouces">
<span class="sig-name descname"><span class="pre">get_resouces</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.Dict" title="(in Python v3.8)"><span class="pre">Dict</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/rotation_gates.html#decomp_mixin.get_resouces"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rotation_gates.decomp_mixin.get_resouces" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rotation_gates.decomp_mixin.num_qubits">
<span class="sig-name descname"><span class="pre">num_qubits</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/rotation_gates.html#decomp_mixin.num_qubits"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rotation_gates.decomp_mixin.num_qubits" title="Link to this definition"></a></dt>
<dd><p>The number of qubits this gate acts on.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rotation_gates.rx_decomp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.rotation_gates.</span></span><span class="sig-name descname"><span class="pre">rx_decomp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#float" title="(in Python v3.8)"><span class="pre">float</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#float" title="(in Python v3.8)"><span class="pre">float</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_random_decomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/rotation_gates.html#rx_decomp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rotation_gates.rx_decomp" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Rx</span></code>, <a class="reference internal" href="#src.pyLIQTR.gate_decomp.rotation_gates.decomp_mixin" title="src.pyLIQTR.gate_decomp.rotation_gates.decomp_mixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">decomp_mixin</span></code></a></p>
<p>A subclass of cirq.Rx that knows its own clifford+T decomposition.</p>
<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rotation_gates.rx_decomp.num_qubits">
<span class="sig-name descname"><span class="pre">num_qubits</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></span><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rotation_gates.rx_decomp.num_qubits" title="Link to this definition"></a></dt>
<dd><p>The number of qubits this gate acts on.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rotation_gates.ry_decomp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.rotation_gates.</span></span><span class="sig-name descname"><span class="pre">ry_decomp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#float" title="(in Python v3.8)"><span class="pre">float</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#float" title="(in Python v3.8)"><span class="pre">float</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_random_decomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/rotation_gates.html#ry_decomp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rotation_gates.ry_decomp" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Ry</span></code>, <a class="reference internal" href="#src.pyLIQTR.gate_decomp.rotation_gates.decomp_mixin" title="src.pyLIQTR.gate_decomp.rotation_gates.decomp_mixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">decomp_mixin</span></code></a></p>
<p>A subclass of cirq.Ry that knows its own clifford+T decomposition.</p>
<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rotation_gates.ry_decomp.num_qubits">
<span class="sig-name descname"><span class="pre">num_qubits</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></span><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rotation_gates.ry_decomp.num_qubits" title="Link to this definition"></a></dt>
<dd><p>The number of qubits this gate acts on.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rotation_gates.rz_decomp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.rotation_gates.</span></span><span class="sig-name descname"><span class="pre">rz_decomp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#float" title="(in Python v3.8)"><span class="pre">float</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#float" title="(in Python v3.8)"><span class="pre">float</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_random_decomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/rotation_gates.html#rz_decomp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rotation_gates.rz_decomp" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Rz</span></code>, <a class="reference internal" href="#src.pyLIQTR.gate_decomp.rotation_gates.decomp_mixin" title="src.pyLIQTR.gate_decomp.rotation_gates.decomp_mixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">decomp_mixin</span></code></a></p>
<p>A subclass of cirq.Rz that knows its own clifford+T decomposition.</p>
<dl class="py method">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.rotation_gates.rz_decomp.num_qubits">
<span class="sig-name descname"><span class="pre">num_qubits</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></span><a class="headerlink" href="#src.pyLIQTR.gate_decomp.rotation_gates.rz_decomp.num_qubits" title="Link to this definition"></a></dt>
<dd><p>The number of qubits this gate acts on.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-src.pyLIQTR.gate_decomp.solve_diophantine">
<span id="src-pyliqtr-gate-decomp-solve-diophantine-module"></span><h2>src.pyLIQTR.gate_decomp.solve_diophantine module<a class="headerlink" href="#module-src.pyLIQTR.gate_decomp.solve_diophantine" title="Link to this heading"></a></h2>
<p>DISTRIBUTION STATEMENT A. Approved for public release. Distribution is unlimited.</p>
<p>This material is based upon work supported by the Under Secretary of Defense for
Research and Engineering under Air Force Contract No. FA8702-15-D-0001. Any opinions,
findings, conclusions or recommendations expressed in this material are those of the
author(s) and do not necessarily reflect the views of the Under Secretary of Defense
for Research and Engineering.</p>
<p>© 2022 Massachusetts Institute of Technology.</p>
<p>The software/firmware is provided to you on an As-Is basis</p>
<p>Delivered to the U.S. Government with Unlimited Rights, as defined in DFARS Part
252.227-7013 or 7014 (Feb 2014). Notwithstanding any copyright notice, U.S. Government
rights in this work are defined by DFARS 252.227-7013 or DFARS 252.227-7014 as detailed
above. Use of this work other than as specifically authorized by the U.S. Government
may violate any copyrights that exist in this work.</p>
<p>Functions used in solving the equation t^* t = E given E ∈ Z[√2], with t ∈ Z[ω].
The approach used for solving the equation is described in [1].
[1] - arXiv:1403.2975</p>
<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.solve_diophantine.find_prime_factor_Z_OMEGA">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.solve_diophantine.</span></span><span class="sig-name descname"><span class="pre">find_prime_factor_Z_OMEGA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_SQRT2" title="src.pyLIQTR.gate_decomp.rings.Z_SQRT2"><span class="pre">Z_SQRT2</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_OMEGA" title="src.pyLIQTR.gate_decomp.rings.Z_OMEGA"><span class="pre">Z_OMEGA</span></a></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/solve_diophantine.html#find_prime_factor_Z_OMEGA"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.solve_diophantine.find_prime_factor_Z_OMEGA" title="Link to this definition"></a></dt>
<dd><p>Given η ∈ Z[√2] such that η | p where p is a prime integer, find a prime
factor of η in Z[ω]</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.solve_diophantine.find_prime_factors_Z_SQRT2">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.solve_diophantine.</span></span><span class="sig-name descname"><span class="pre">find_prime_factors_Z_SQRT2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3.8/library/typing.html#typing.List" title="(in Python v3.8)"><span class="pre">List</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_SQRT2" title="src.pyLIQTR.gate_decomp.rings.Z_SQRT2"><span class="pre">Z_SQRT2</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/solve_diophantine.html#find_prime_factors_Z_SQRT2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.solve_diophantine.find_prime_factors_Z_SQRT2" title="Link to this definition"></a></dt>
<dd><p>Given a prime integer p, find its prime factorization in the ring Z[√2]</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.solve_diophantine.find_prime_factors_integers">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.solve_diophantine.</span></span><span class="sig-name descname"><span class="pre">find_prime_factors_integers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/solve_diophantine.html#find_prime_factors_integers"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.solve_diophantine.find_prime_factors_integers" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.solve_diophantine.g_minus">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.solve_diophantine.</span></span><span class="sig-name descname"><span class="pre">g_minus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/solve_diophantine.html#g_minus"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.solve_diophantine.g_minus" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.solve_diophantine.g_plus">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.solve_diophantine.</span></span><span class="sig-name descname"><span class="pre">g_plus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/solve_diophantine.html#g_plus"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.solve_diophantine.g_plus" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.solve_diophantine.is_prime">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.solve_diophantine.</span></span><span class="sig-name descname"><span class="pre">is_prime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/solve_diophantine.html#is_prime"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.solve_diophantine.is_prime" title="Link to this definition"></a></dt>
<dd><p>Use the fermat primaility test to determine if n is prime</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.solve_diophantine.modular_sqrtm1">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.solve_diophantine.</span></span><span class="sig-name descname"><span class="pre">modular_sqrtm1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/solve_diophantine.html#modular_sqrtm1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.solve_diophantine.modular_sqrtm1" title="Link to this definition"></a></dt>
<dd><p>Find the square root of -1 mod p.</p>
<p>Return None if no h is found. Algorithm described in remark 11 of arXiv:1212.6253.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.solve_diophantine.modular_square_root">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.solve_diophantine.</span></span><span class="sig-name descname"><span class="pre">modular_square_root</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/solve_diophantine.html#modular_square_root"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.solve_diophantine.modular_square_root" title="Link to this definition"></a></dt>
<dd><p>Calculate the modular square root with the Tonelli-Shanks algorithm</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.solve_diophantine.pollard_rho">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.solve_diophantine.</span></span><span class="sig-name descname"><span class="pre">pollard_rho</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3.8/library/functions.html#int" title="(in Python v3.8)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_plus</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/solve_diophantine.html#pollard_rho"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.solve_diophantine.pollard_rho" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.solve_diophantine.ring_gcd">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.solve_diophantine.</span></span><span class="sig-name descname"><span class="pre">ring_gcd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/solve_diophantine.html#ring_gcd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.solve_diophantine.ring_gcd" title="Link to this definition"></a></dt>
<dd><p>Calculate the gcd of a and b</p>
<p>Works for any type that has the __mod__ operator defined, but should not be used
when a and b are integers, as the built-in in math.gcd() is much faster</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.pyLIQTR.gate_decomp.solve_diophantine.solveDiophantine">
<span class="sig-prename descclassname"><span class="pre">src.pyLIQTR.gate_decomp.solve_diophantine.</span></span><span class="sig-name descname"><span class="pre">solveDiophantine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xi</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#src.pyLIQTR.gate_decomp.rings.Z_SQRT2" title="src.pyLIQTR.gate_decomp.rings.Z_SQRT2"><span class="pre">Z_SQRT2</span></a></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/src/pyLIQTR/gate_decomp/solve_diophantine.html#solveDiophantine"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#src.pyLIQTR.gate_decomp.solve_diophantine.solveDiophantine" title="Link to this definition"></a></dt>
<dd><p>Given some E = x + y√2 ∈ Z[√2], try to solve the Diophantine equation
t^* t = E
for t ∈ Z[ω]. Return None if no solution is found.</p>
</dd></dl>

</section>
<section id="module-src.pyLIQTR.gate_decomp">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-src.pyLIQTR.gate_decomp" title="Link to this heading"></a></h2>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, MIT Lincoln Laboratory.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>